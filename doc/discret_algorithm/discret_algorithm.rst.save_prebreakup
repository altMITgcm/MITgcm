.. _discret_algorithm:

Discretization and Algorithm
****************************

This chapter lays out the numerical schemes that are employed in the
core MITgcm algorithm. Whenever possible links are made to actual
program code in the MITgcm implementation. The chapter begins with a
discussion of the temporal discretization used in MITgcm. This
discussion is followed by sections that describe the spatial
discretization. The schemes employed for momentum terms are described
first, afterwards the schemes that apply to passive and dynamically
active tracers are described.

Notation
========

Because of the particularity of the vertical direction in stratified
fluid context, in this chapter, the vector notations are mostly used for
the horizontal component: the horizontal part of a vector is simply
written :math:`\vec{\bf v}` (instead of :math:`{\bf v_h}` or
:math:`\vec{\mathbf{v}}_{h}` in chapter 1) and a 3D vector is simply
written :math:`\vec{v}` (instead of :math:`\vec{\mathbf{v}}` in chapter
1).

The notations we use to describe the discrete formulation of the model
are summarized as follows.

General notation:

| :math:`\Delta x, \Delta y, \Delta r` grid spacing in X, Y, R directions
|
| :math:`A_c,A_w,A_s,A_{\zeta}` : horizontal area of a grid cell
  surrounding :math:`\theta,u,v,\zeta` point
|
| :math:`{\cal V}_u , {\cal V}_v , {\cal V}_w , {\cal V}_\theta` :
  Volume of the grid box surrounding :math:`u,v,w,\theta` point
|
| :math:`i,j,k` : current index relative to X, Y, R directions
| 
Basic operators:

| :math:`\delta_i` :
  :math:`\delta_i \Phi = \Phi_{i+1/2} - \Phi_{i-1/2}`
|
| :math:`~^{-i}` :
  :math:`\overline{\Phi}^i = ( \Phi_{i+1/2} + \Phi_{i-1/2} ) / 2`
|
| :math:`\delta_x` :
  :math:`\delta_x \Phi = \frac{1}{\Delta x} \delta_i \Phi`
|
| :math:`\overline{\nabla}` = horizontal gradient operator :
  :math:`\overline{\nabla} \Phi = \{ \delta_x \Phi , \delta_y \Phi \}`
|
| :math:`\overline{\nabla} \cdot` = horizontal divergence operator :
  :math:`\overline{\nabla}\cdot \vec{\mathrm{f}}  = 
  \frac{1}{\cal A} \{ \delta_i \Delta y \, \mathrm{f}_x 
                    + \delta_j \Delta x \, \mathrm{f}_y \}`
|
| :math:`\overline{\nabla}^2` = horizontal Laplacian operator :
  :math:`\overline{\nabla}^2 \Phi = 
     \overline{\nabla}\cdot \overline{\nabla}\Phi`
|

Time-stepping
=============

The equations of motion integrated by the model involve four prognostic
equations for flow, :math:`u` and :math:`v`, temperature,
:math:`\theta`, and salt/moisture, :math:`S`, and three diagnostic
equations for vertical flow, :math:`w`, density/buoyancy,
:math:`\rho`/:math:`b`, and pressure/geo-potential, :math:`\phi_{hyd}`.
In addition, the surface pressure or height may by described by either a
prognostic or diagnostic equation and if non-hydrostatics terms are
included then a diagnostic equation for non-hydrostatic pressure is also
solved. The combination of prognostic and diagnostic equations requires
a model algorithm that can march forward prognostic variables while
satisfying constraints imposed by diagnostic equations.

Since the model comes in several flavors and formulation, it would be
confusing to present the model algorithm exactly as written into code
along with all the switches and optional terms. Instead, we present the
algorithm for each of the basic formulations which are:

#. the semi-implicit pressure method for hydrostatic equations with a
   rigid-lid, variables co-located in time and with Adams-Bashforth
   time-stepping; 

#. as 1 but with an implicit linear free-surface;

#. as 1 or 2 but with variables staggered in time;

#. as 1 or 2 but with non-hydrostatic terms included;

#. as 2 or 3 but with non-linear free-surface.

In all the above configurations it is also possible to substitute the
Adams-Bashforth with an alternative time-stepping scheme for terms
evaluated explicitly in time. Since the over-arching algorithm is
independent of the particular time-stepping scheme chosen we will
describe first the over-arching algorithm, known as the pressure method,
with a rigid-lid model in :numref:`press_meth_rigid`. This
algorithm is essentially unchanged, apart for some coefficients, when
the rigid lid assumption is replaced with a linearized implicit
free-surface, described in :numref:`press_meth_linear`. These two flavors of the
pressure-method encompass all formulations of the model as it exists
today. The integration of explicit in time terms is out-lined in
:numref:`adams-bashforth` and put into the context of the overall algorithm
in :numref:`adams-bashforth-sync` and :numref:`adams-bashforth-staggered`.
Inclusion of non-hydrostatic terms
requires applying the pressure method in three dimensions instead of two
and this algorithm modification is described in
:numref:`non-hydrostatic`. Finally, the free-surface equation may be treated
more exactly, including non-linear terms, and this is described in
:numref:`nonlinear-freesurface`.

.. _press_meth_rigid:
 
Pressure method with rigid-lid
==============================

The horizontal momentum and continuity equations for the ocean
(:eq:`eq-ocean-mom` and :eq:`eq-ocean-cont`), or for the atmosphere
(:eq:`atmos-mom` and :eq:`atmos-cont`), can be summarized by:

.. math::

   \begin{aligned}
   \partial_t u + g \partial_x \eta & = & G_u \\
   \partial_t v + g \partial_y \eta & = & G_v \\
   \partial_x u + \partial_y v + \partial_z w & = & 0\end{aligned}

where we are adopting the oceanic notation for brevity. All terms in
the momentum equations, except for surface pressure gradient, are
encapsulated in the :math:`G` vector. The continuity equation, when
integrated over the fluid depth, :math:`H`, and with the rigid-lid/no
normal flow boundary conditions applied, becomes:

.. math::
   \partial_x H \widehat{u} + \partial_y H \widehat{v} = 0
   :label: rigid-lid-continuity

Here, :math:`H\widehat{u} = \int_H u dz` is the depth integral of
:math:`u`, similarly for :math:`H\widehat{v}`. The rigid-lid
approximation sets :math:`w=0` at the lid so that it does not move but
allows a pressure to be exerted on the fluid by the lid. The horizontal
momentum equations and vertically integrated continuity equation are be
discretized in time and space as follows:

.. math::
   u^{n+1} + \Delta t g \partial_x \eta^{n+1}
   =  u^{n} + \Delta t G_u^{(n+1/2)}
   :label: discrete-time-u

.. math::
   v^{n+1} + \Delta t g \partial_y \eta^{n+1}
   = v^{n} + \Delta t G_v^{(n+1/2)}
   :label: discrete-time-v

.. math::
   \partial_x H \widehat{u^{n+1}}
   + \partial_y H \widehat{v^{n+1}} = 0
   :label: discrete-time-cont-rigid-lid

As written here, terms on the LHS all involve time level :math:`n+1`
and are referred to as implicit; the implicit backward time stepping
scheme is being used. All other terms in the RHS are explicit in time.
The thermodynamic quantities are integrated forward in time in parallel
with the flow and will be discussed later. For the purposes of
describing the pressure method it suffices to say that the hydrostatic
pressure gradient is explicit and so can be included in the vector
:math:`G`.

Substituting the two momentum equations into the depth integrated
continuity equation eliminates :math:`u^{n+1}` and :math:`v^{n+1}`
yielding an elliptic equation for :math:`\eta^{n+1}`. Equations
:eq:`discrete-time-u`, :eq:`discrete-time-v` and
:eq:`discrete-time-cont-rigid-lid` can then be re-arranged as follows:

.. math:: u^{*} = u^{n} + \Delta t G_u^{(n+1/2)}
   :label: ustar-rigid-lid

.. math:: v^{*} = v^{n} + \Delta t G_v^{(n+1/2)}
   :label: vstar-rigid-lid

.. math:: \partial_x \Delta t g H \partial_x \eta^{n+1}
   + \partial_y \Delta t g H \partial_y \eta^{n+1}
   = \partial_x H \widehat{u^{*}}
   + \partial_y H \widehat{v^{*}} 
   :label: elliptic

.. math:: u^{n+1} = u^{*} - \Delta t g \partial_x \eta^{n+1}
   :label: un+1-rigid-lid

.. math:: v^{n+1} = v^{*} - \Delta t g \partial_y \eta^{n+1}
   :label: vn+1-rigid-lid

Equations :eq:`ustar-rigid-lid` to :eq:`vn+1-rigid-lid`, solved
sequentially, represent the pressure method algorithm used in the model.
The essence of the pressure method lies in the fact that any explicit
prediction for the flow would lead to a divergence flow field so a
pressure field must be found that keeps the flow non-divergent over each
step of the integration. The particular location in time of the pressure
field is somewhat ambiguous; in :numref:`pressure-method-rigid-lid` we
depicted as co-located with the future flow field (time level
:math:`n+1`) but it could equally have been drawn as staggered in time
with the flow.

  .. figure:: figs/pressure-method-rigid-lid.*
    :width: 70%
    :align: center
    :alt: pressure-method-rigid-lid
    :name: pressure-method-rigid-lid

    A schematic of the evolution in time of the pressure method algorithm. A prediction for the flow variables at time level :math:`n+1` is made based only on the explicit terms, :math:`G^{(n+^1/_2)}`, and denoted :math:`u^*`, :math:`v^*`. Next, a pressure field is found such that :math:`u^{n+1}`, :math:`v^{n+1}` will be non-divergent. Conceptually, the :math:`*` quantities exist at time level :math:`n+1` but they are intermediate and only temporary.


The correspondence to the code is as follows:

-  the prognostic phase, equations :eq:`ustar-rigid-lid` and
   :eq:`vstar-rigid-lid`, stepping forward :math:`u^n` and :math:`v^n` to
   :math:`u^{*}` and :math:`v^{*}` is coded in :filelink:`timestep.F <model/src/timestep.F>`

-  the vertical integration, :math:`H \widehat{u^*}` and :math:`H
   \widehat{v^*}`, divergence and inversion of the elliptic operator in
   equation :eq:`elliptic` is coded in :filelink:`solve_for_pressure.F <model/src/solve_for_pressure.F>`

-  finally, the new flow field at time level :math:`n+1` given by
   equations :eq:`un+1-rigid-lid` and :eq:`vn+1-rigid-lid` is calculated
   in :filelink:`correction_step.F <model/src/correction_step.F>`

The calling tree for these routines is as follows:

.. _call-tree-press-meth:

.. admonition:: Pressure method calling tree
  :class: note

    | :filelink:`FORWARD\_STEP <model/src/forward_step.F>`
    | :math:`\phantom{W}` :filelink:`DYNAMICS <model/src/dynamics.F>`
    | :math:`\phantom{WW}` :filelink:`TIMESTEP <model/src/timestep.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxx}` :math:`u^*,v^*` :eq:`ustar-rigid-lid` , :eq:`vstar-rigid-lid`
    | :math:`\phantom{W}` :filelink:`SOLVE\_FOR\_PRESSURE <model/src/solve_for_pressure.F>`
    | :math:`\phantom{WW}` :filelink:`CALC\_DIV\_GHAT <model/src/calc_div_ghat.F>` :math:`\phantom{xxxxxxxxxxxxxxxx}` :math:`H\widehat{u^*},H\widehat{v^*}` :eq:`elliptic`
    | :math:`\phantom{WW}` :filelink:`CG2D <model/src/cg2d.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxxxxxx}` :math:`\eta^{n+1}` :eq:`elliptic`
    | :math:`\phantom{W}` :filelink:`MOMENTUM\_CORRECTION\_STEP <model/src/momentum_correction_step.F>`
    | :math:`\phantom{WW}` :filelink:`CALC\_GRAD\_PHI\_SURF <model/src/calc_grad_phi_surf.F>` :math:`\phantom{xxxxxxxxxx}` :math:`\nabla \eta^{n+1}`
    | :math:`\phantom{WW}` :filelink:`CORRECTION\_STEP  <model/src/correction_step.F>` :math:`\phantom{xxxxxxxxxxxxw}` :math:`u^{n+1},v^{n+1}` :eq:`un+1-rigid-lid` , :eq:`vn+1-rigid-lid`

In general, the horizontal momentum time-stepping can contain some terms
that are treated implicitly in time, such as the vertical viscosity when
using the backward time-stepping scheme (:varlink:`implicitViscosity` =.TRUE.). The method used to solve
those implicit terms is provided in :numref:`implicit-backward-stepping`, and modifies equations
:eq:`discrete-time-u` and :eq:`discrete-time-v` to give:

.. math::

   \begin{aligned}
   u^{n+1} - \Delta t \partial_z A_v \partial_z u^{n+1}
   + \Delta t g \partial_x \eta^{n+1} & = & u^{n} + \Delta t G_u^{(n+1/2)}
   \\
   v^{n+1} - \Delta t \partial_z A_v \partial_z v^{n+1}
   + \Delta t g \partial_y \eta^{n+1} & = & v^{n} + \Delta t G_v^{(n+1/2)}\end{aligned}


.. _press_meth_linear:

Pressure method with implicit linear free-surface
=================================================

The rigid-lid approximation filters out external gravity waves
subsequently modifying the dispersion relation of barotropic Rossby
waves. The discrete form of the elliptic equation has some zero
eigen-values which makes it a potentially tricky or inefficient problem
to solve.

The rigid-lid approximation can be easily replaced by a linearization of
the free-surface equation which can be written:

.. math::
   \partial_t \eta + \partial_x H \widehat{u} + \partial_y H \widehat{v} = P-E+R
   :label: linear-free-surface=P-E

which differs from the depth integrated continuity equation with
rigid-lid (:eq:`rigid-lid-continuity`) by the time-dependent term and
fresh-water source term.

Equation :eq:`discrete-time-cont-rigid-lid` in the rigid-lid pressure
method is then replaced by the time discretization of
:eq:`linear-free-surface=P-E` which is:

.. math::
   \eta^{n+1}
   + \Delta t \partial_x H \widehat{u^{n+1}}
   + \Delta t \partial_y H \widehat{v^{n+1}}
   = \eta^{n} + \Delta t ( P - E )
   :label: discrete-time-backward-free-surface

where the use of flow at time level :math:`n+1` makes the method
implicit and backward in time. This is the preferred scheme since it
still filters the fast unresolved wave motions by damping them. A
centered scheme, such as Crank-Nicholson (see
:numref:`crank-nicolson_baro`), would alias the energy of the fast modes onto
slower modes of motion.

As for the rigid-lid pressure method, equations :eq:`discrete-time-u`,
:eq:`discrete-time-v` and :eq:`discrete-time-backward-free-surface` can be
re-arranged as follows:

.. math::
   u^{*} = u^{n} + \Delta t G_u^{(n+1/2)}
   :label: ustar-backward-free-surface

.. math::
   v^{*} = v^{n} + \Delta t G_v^{(n+1/2)}
   :label: vstar-backward-free-surface

.. math::
   \eta^* = \epsilon_{fs} ( \eta^{n} + \Delta t (P-E) )
            - \Delta t ( \partial_x H \widehat{u^{*}}
                            + \partial_y H \widehat{v^{*}} )
   :label: etastar-backward-free-surface

.. math::
   \partial_x g H \partial_x \eta^{n+1}
   + \partial_y g H \partial_y \eta^{n+1}
   - \frac{\epsilon_{fs} \eta^{n+1}}{\Delta t^2} =
   - \frac{\eta^*}{\Delta t^2}
   :label: elliptic-backward-free-surface

.. math::
   u^{n+1} = u^{*} - \Delta t g \partial_x \eta^{n+1}
   :label: un+1-backward-free-surface

.. math::
   v^{n+1} = v^{*} - \Delta t g \partial_y \eta^{n+1}
   :label: vn+1-backward-free-surface

Equations :eq:`ustar-backward-free-surface`
to :eq:`vn+1-backward-free-surface`, solved sequentially, represent the
pressure method algorithm with a backward implicit, linearized free
surface. The method is still formerly a pressure method because in the
limit of large :math:`\Delta t` the rigid-lid method is recovered.
However, the implicit treatment of the free-surface allows the flow to
be divergent and for the surface pressure/elevation to respond on a
finite time-scale (as opposed to instantly). To recover the rigid-lid
formulation, we introduced a switch-like parameter,
:math:`\epsilon_{fs}` (:varlink:`freesurfFac`), which selects between the free-surface and
rigid-lid; :math:`\epsilon_{fs}=1` allows the free-surface to evolve;
:math:`\epsilon_{fs}=0` imposes the rigid-lid. The evolution in time and
location of variables is exactly as it was for the rigid-lid model so
that :numref:`pressure-method-rigid-lid` is still applicable.
Similarly, the calling sequence, given :ref:`here <call-tree-press-meth>`, is as for the pressure-method.

.. _adams-bashforth:

Explicit time-stepping: Adams-Bashforth
=======================================

In describing the the pressure method above we deferred describing the
time discretization of the explicit terms. We have historically used the
quasi-second order Adams-Bashforth method for all explicit terms in both
the momentum and tracer equations. This is still the default mode of
operation but it is now possible to use alternate schemes for tracers
(see :numref:`tracer-advection`). In the previous sections, we summarized an explicit scheme as:

.. math::
   \tau^{*} = \tau^{n} + \Delta t G_\tau^{(n+1/2)}
   :label: taustar

where :math:`\tau` could be any prognostic variable (:math:`u`,
:math:`v`, :math:`\theta` or :math:`S`) and :math:`\tau^*` is an
explicit estimate of :math:`\tau^{n+1}` and would be exact if not for
implicit-in-time terms. The parenthesis about :math:`n+1/2` indicates
that the term is explicit and extrapolated forward in time and for this
we use the quasi-second order Adams-Bashforth method:

.. math::
   G_\tau^{(n+1/2)} = ( 3/2 + \epsilon_{AB}) G_\tau^n
   - ( 1/2 + \epsilon_{AB}) G_\tau^{n-1}
   :label: adams-bashforth2

This is a linear extrapolation, forward in time, to
:math:`t=(n+1/2+{\epsilon_{AB}})\Delta t`. An extrapolation to the
mid-point in time, :math:`t=(n+1/2)\Delta t`, corresponding to
:math:`\epsilon_{AB}=0`, would be second order accurate but is weakly
unstable for oscillatory terms. A small but finite value for
:math:`\epsilon_{AB}` stabilizes the method. Strictly speaking, damping
terms such as diffusion and dissipation, and fixed terms (forcing), do
not need to be inside the Adams-Bashforth extrapolation. However, in the
current code, it is simpler to include these terms and this can be
justified if the flow and forcing evolves smoothly. Problems can, and
do, arise when forcing or motions are high frequency and this
corresponds to a reduced stability compared to a simple forward
time-stepping of such terms. The model offers the possibility to leave
terms outside the Adams-Bashforth extrapolation, by turning off the logical flag :varlink:`forcing_In_AB`
(parameter file ``data``, namelist ``PARM01``, default value = TRUE) and then setting :varlink:`tracForcingOutAB`
(default=0), :varlink:`momForcingOutAB` (default=0), and :varlink:`momDissip_In_AB` (parameter file ``data``, namelist ``PARM01``,
default value = TRUE), respectively for the tracer terms, momentum forcing terms, and the dissipation terms.

A stability analysis for an oscillation equation should be given at this
point.

A stability analysis for a relaxation equation should be given at this
point.


  .. figure:: figs/oscil+damp_AB2.*
    :width: 100%
    :align: center
    :alt: stability_analysis
    :name: oscil+damp_AB2

    Oscillatory and damping response of quasi-second order Adams-Bashforth scheme for different values of the  :math:`\epsilon _{AB}` parameter (0.0, 0.1, 0.25, from top to bottom) The analytical solution (in black), the physical mode (in blue) and the numerical mode (in red) are represented with a CFL step of 0.1. The left column represents the oscillatory response on the complex plane for CFL ranging from 0.1 up to 0.9. The right column represents the damping response amplitude (y-axis) function of the CFL (x-axis).

.. _implicit-backward-stepping:

Implicit time-stepping: backward method
=======================================

Vertical diffusion and viscosity can be treated implicitly in time using
the backward method which is an intrinsic scheme. Recently, the option
to treat the vertical advection implicitly has been added, but not yet
tested; therefore, the description hereafter is limited to diffusion and
viscosity. For tracers, the time discretized equation is:

.. math::
   \tau^{n+1} - \Delta t \partial_r \kappa_v \partial_r \tau^{n+1} = \tau^{n} + \Delta t G_\tau^{(n+1/2)}
   :label: implicit-diffusion

where :math:`G_\tau^{(n+1/2)}` is the remaining explicit terms
extrapolated using the Adams-Bashforth method as described above.
Equation :eq:`implicit-diffusion` can be split split into:

.. math::
   \tau^* = \tau^{n} + \Delta t G_\tau^{(n+1/2)}
   :label: taustar-implicit

.. math::
   \tau^{n+1} = {\cal L}_\tau^{-1} ( \tau^* )
   :label: tau-n+1-implicit

where :math:`{\cal L}_\tau^{-1}` is the inverse of the operator

.. math:: {\cal L}_\tau = \left[ 1 + \Delta t \partial_r \kappa_v \partial_r \right]

Equation :eq:`taustar-implicit` looks exactly as :eq:`taustar` while
:eq:`tau-n+1-implicit` involves an operator or matrix inversion. By
re-arranging :eq:`implicit-diffusion` in this way we have cast the method
as an explicit prediction step and an implicit step allowing the latter
to be inserted into the over all algorithm with minimal interference.

The calling sequence for stepping forward a tracer variable such as temperature with implicit diffusion is
as follows:

.. _adams-bash-calltree:

.. admonition:: Adams-Bashforth calling tree
  :class: note

    | :filelink:`FORWARD\_STEP <model/src/forward_step.F>`
    | :math:`\phantom{W}` :filelink:`THERMODYNAMICS <model/src/thermodynamics.F>`
    | :math:`\phantom{WW}` :filelink:`TEMP\_INTEGRATE <model/src/temp_integrate.F>`
    | :math:`\phantom{WWW}` :filelink:`GAD\_CALC\_RHS <pkg/generic_advdiff/gad_calc_rhs.F>` :math:`\phantom{xxxxxxxxxw}` :math:`G_\theta^n = G_\theta( u, \theta^n)`
    | :math:`\phantom{WWW}` either
    | :math:`\phantom{WWWW}` :filelink:`EXTERNAL\_FORCING <model/src/external_forcing.F>` :math:`\phantom{xxxx}` :math:`G_\theta^n = G_\theta^n + {\cal Q}`
    | :math:`\phantom{WWWW}` :filelink:`ADAMS\_BASHFORTH2 <model/src/adams_bashforth2.F>` :math:`\phantom{xxi}` :math:`G_\theta^{(n+1/2)}` :eq:`adams-bashforth2`
    | :math:`\phantom{WWW}` or
    | :math:`\phantom{WWWW}` :filelink:`EXTERNAL\_FORCING <model/src/external_forcing.F>` :math:`\phantom{xxxx}` :math:`G_\theta^{(n+1/2)} = G_\theta^{(n+1/2)} + {\cal Q}`
    | :math:`\phantom{WW}` :filelink:`TIMESTEP\_TRACER <model/src/timestep_tracer.F>` :math:`\phantom{xxxxxxxxxx}` :math:`\tau^*` :eq:`taustar`
    | :math:`\phantom{WW}` :filelink:`IMPLDIFF  <model/src/impldiff.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxw}` :math:`\tau^{(n+1)}` :eq:`tau-n+1-implicit`

In order to fit within the pressure method, the implicit viscosity must
not alter the barotropic flow. In other words, it can only redistribute
momentum in the vertical. The upshot of this is that although vertical
viscosity may be backward implicit and unconditionally stable, no-slip
boundary conditions may not be made implicit and are thus cast as a an
explicit drag term.

.. _adams-bashforth-sync:

Synchronous time-stepping: variables co-located in time
=======================================================

  .. figure:: figs/adams-bashforth-sync.*
    :width: 70%
    :align: center
    :alt: adams-bash-sync
    :name: adams-bash-sync

    A schematic of the explicit Adams-Bashforth and implicit time-stepping phases of the algorithm. All prognostic variables are co-located in time. Explicit tendencies are evaluated at time level :math:`n` as a function of the state at that time level (dotted arrow). The explicit tendency from the previous time level, :math:`n-1`, is used to extrapolate tendencies to :math:`n+1/2` (dashed arrow). This extrapolated tendency allows variables to be stably integrated forward-in-time to render an estimate (:math:`*` -variables) at the :math:`n+1` time level (solid arc-arrow). The operator :math:`{\cal L}` formed from implicit-in-time terms is solved to yield the state variables at time level :math:`n+1`.


The Adams-Bashforth extrapolation of explicit tendencies fits neatly
into the pressure method algorithm when all state variables are
co-located in time. The algorithm can be represented by the sequential solution of the
follow equations:

.. math::   
   G_{\theta,S}^{n} = G_{\theta,S} ( u^n, \theta^n, S^n )
   :label: Gt-n-sync

.. math::
   G_{\theta,S}^{(n+1/2)} = (3/2+\epsilon_{AB}) G_{\theta,S}^{n}-(1/2+\epsilon_{AB}) G_{\theta,S}^{n-1}
   :label: Gt-n+5-sync

.. math::
   (\theta^*,S^*) = (\theta^{n},S^{n}) + \Delta t G_{\theta,S}^{(n+1/2)}
   :label: tstar-sync

.. math::
   (\theta^{n+1},S^{n+1}) = {\cal L}^{-1}_{\theta,S} (\theta^*,S^*)
   :label: t-n+1-sync

.. math::
   \phi^n_{hyd} = \int b(\theta^n,S^n) dr
   :label: phi-hyd-sync

.. math::
   \vec{\bf G}_{\vec{\bf v}}^{n} = \vec{\bf G}_{\vec{\bf v}} ( \vec{\bf v}^n, \phi^n_{hyd} )
   :label: Gv-n-sync

.. math::
   \vec{\bf G}_{\vec{\bf v}}^{(n+1/2)} = (3/2 + \epsilon_{AB} ) \vec{\bf G}_{\vec{\bf v}}^{n} - (1/2 + \epsilon_{AB} ) \vec{\bf G}_{\vec{\bf v}}^{n-1}
   :label: Gv-n+5-sync

.. math::
   \vec{\bf v}^{*} = \vec{\bf v}^{n} + \Delta t \vec{\bf G}_{\vec{\bf v}}^{(n+1/2)}
   :label: vstar-sync

.. math::
   \vec{\bf v}^{**} = {\cal L}_{\vec{\bf v}}^{-1} ( \vec{\bf v}^* )
   :label: vstarstar-sync

.. math::
   \eta^* = \epsilon_{fs} \left( \eta^{n} + \Delta t (P-E) \right)- \Delta t
     \nabla \cdot H \widehat{ \vec{\bf v}^{**} }
   :label: nstar-sync

.. math::
   \nabla \cdot g H \nabla \eta^{n+1} - \frac{\epsilon_{fs} \eta^{n+1}}{\Delta t^2} ~ = ~ - \frac{\eta^*}{\Delta t^2}
   :label: elliptic-sync

.. math::
   \vec{\bf v}^{n+1} = \vec{\bf v}^{**} - \Delta t g \nabla \eta^{n+1}
   :label: v-n+1-sync

:numref:`adams-bash-sync` illustrates the location of variables
in time and evolution of the algorithm with time. The Adams-Bashforth
extrapolation of the tracer tendencies is illustrated by the dashed
arrow, the prediction at :math:`n+1` is indicated by the solid arc.
Inversion of the implicit terms, :math:`{\cal
L}^{-1}_{\theta,S}`, then yields the new tracer fields at :math:`n+1`.
All these operations are carried out in subroutine :filelink:`THERMODYNAMICS <model/src/thermodynamics.F>` and
subsidiaries, which correspond to equations :eq:`Gt-n-sync` to
:eq:`t-n+1-sync`. Similarly illustrated is the Adams-Bashforth
extrapolation of accelerations, stepping forward and solving of implicit
viscosity and surface pressure gradient terms, corresponding to
equations :eq:`Gv-n-sync` to :eq:`v-n+1-sync`. These operations are
carried out in subroutines :filelink:`DYNAMICS <model/src/dynamics.F>`,
:filelink:`SOLVE\_FOR\_PRESSURE <model/src/solve_for_pressure.F>` and
:filelink:`MOMENTUM\_CORRECTION\_STEP <model/src/momentum_correction_step.F>`.
This, then, represents an entire algorithm
for stepping forward the model one time-step. The corresponding calling
tree for the overall synchronous algorithm using
Adams-Bashforth time-stepping is given below. The place where the model geometry
**hFac** factors) is updated is added here but is only relevant
for the non-linear free-surface algorithm.
For completeness, the external forcing,
ocean and atmospheric physics have been added, although they are mainly optional.

.. admonition:: Synchronous Adams-Bashforth calling tree
  :class: note

    | :filelink:`FORWARD\_STEP <model/src/forward_step.F>`
    | :math:`\phantom{WWW}` :filelink:`EXTERNAL\_FIELDS\_LOAD <model/src/external_fields_load.F>`
    | :math:`\phantom{WWW}` :filelink:`DO\_ATMOSPHERIC\_PHYS <model/src/do_atmospheric_phys.F>`
    | :math:`\phantom{WWW}` :filelink:`DO\_OCEANIC\_PHYS <model/src/do_oceanic_phys.F>`
    | :math:`\phantom{WW}` :filelink:`THERMODYNAMICS <model/src/thermodynamics.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_GT <model/src/calc_gt.F>`
    | :math:`\phantom{WWWW}` :filelink:`GAD\_CALC\_RHS <pkg/generic_advdiff/gad_calc_rhs.F>` :math:`\phantom{xxxxxxxxxxxxxlwww}` :math:`G_\theta^n = G_\theta( u, \theta^n )` :eq:`Gt-n-sync`
    | :math:`\phantom{WWWW}` :filelink:`EXTERNAL\_FORCING <model/src/external_forcing.F>` :math:`\phantom{xxxxxxxxxxlww}` :math:`G_\theta^n = G_\theta^n + {\cal Q}`
    | :math:`\phantom{WWWW}` :filelink:`ADAMS\_BASHFORTH2 <model/src/adams_bashforth2.F>` :math:`\phantom{xxxxxxxxxxxw}` :math:`G_\theta^{(n+1/2)}` :eq:`Gt-n+5-sync`
    | :math:`\phantom{WWW}` :filelink:`TIMESTEP\_TRACER <model/src/timestep_tracer.F>` :math:`\phantom{xxxxxxxxxxxxxxxww}` :math:`\theta^*` :eq:`tstar-sync`
    | :math:`\phantom{WWW}` :filelink:`IMPLDIFF  <model/src/impldiff.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxvwww}` :math:`\theta^{(n+1)}` :eq:`t-n+1-sync`
    | :math:`\phantom{WW}` :filelink:`DYNAMICS <model/src/dynamics.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_PHI\_HYD <model/src/calc_phi_hyd.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxi}` :math:`\phi_{hyd}^n` :eq:`phi-hyd-sync`
    | :math:`\phantom{WWW}` :filelink:`MOM\_FLUXFORM <pkg/mom_fluxform/mom_fluxform.F>` or :filelink:`MOM\_VECINV <pkg/mom_vecinv/mom_vecinv.F>` :math:`\phantom{xxi}` :math:`G_{\vec{\bf v}}^n` :eq:`Gv-n-sync`
    | :math:`\phantom{WWW}` :filelink:`TIMESTEP <model/src/timestep.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxxxxxx}` :math:`\vec{\bf v}^*` :eq:`Gv-n+5-sync`, :eq:`vstar-sync`
    | :math:`\phantom{WWW}` :filelink:`IMPLDIFF  <model/src/impldiff.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxxxxlw}` :math:`\vec{\bf v}^{**}` :eq:`vstarstar-sync`
    | :math:`\phantom{WW}` :filelink:`UPDATE\_R\_STAR <model/src/update_r_star.F>` or :filelink:`UPDATE\_SURF\_DR <model/src/update_surf_dr.F>` (NonLin-FS only)
    | :math:`\phantom{WW}` :filelink:`SOLVE\_FOR\_PRESSURE <model/src/solve_for_pressure.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_DIV\_GHAT <model/src/calc_div_ghat.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxx}` :math:`\eta^*` :eq:`nstar-sync`
    | :math:`\phantom{WWW}` :filelink:`CG2D <model/src/cg2d.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxi}` :math:`\eta^{n+1}` :eq:`elliptic-sync`
    | :math:`\phantom{WW}` :filelink:`MOMENTUM\_CORRECTION\_STEP <model/src/momentum_correction_step.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_GRAD\_PHI\_SURF <model/src/calc_grad_phi_surf.F>` :math:`\phantom{xxxxxxxxxxxxxx}` :math:`\nabla \eta^{n+1}`
    | :math:`\phantom{WWW}` :filelink:`CORRECTION\_STEP  <model/src/correction_step.F>` :math:`\phantom{xxxxxxxxxxxxxxxxw}` :math:`u^{n+1},v^{n+1}` :eq:`v-n+1-sync`
    | :math:`\phantom{WW}` :filelink:`TRACERS\_CORRECTION\_STEP <model/src/tracers_correction_step.F>`
    | :math:`\phantom{WWW}` :filelink:`CYCLE\_TRACER <model/src/cycle_tracer.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxx}` :math:`\theta^{n+1}`
    | :math:`\phantom{WWW}` :filelink:`SHAP_FILT_APPLY_TS  <pkg/shap_filt/shap_filt_apply_ts.F>` or :filelink:`ZONAL_FILT_APPLY_TS  <pkg/zonal_filt/zonal_filt_apply_ts.F>`
    | :math:`\phantom{WWW}` :filelink:`CONVECTIVE_ADJUSTMENT  <model/src/convective_adjustment.F>`


.. _adams-bashforth-staggered:

Staggered baroclinic time-stepping
==================================

  .. figure:: figs/adams-bashforth-staggered.*
    :width: 80%
    :align: center
    :alt: adams-bash-staggered
    :name: adams-bash-staggered

    A schematic of the explicit Adams-Bashforth and implicit time-stepping phases of the algorithm but with staggering in time of thermodynamic variables with the flow. Explicit momentum tendencies are evaluated at time level :math:`n-1/2` as a function of the flow field at that time level :math:`n-1/2`. The explicit tendency from the previous time level, :math:`n-3/2`, is used to extrapolate tendencies to :math:`n` (dashed arrow). The hydrostatic pressure/geo-potential  :math:`\phi _{hyd}` is evaluated directly at time level :math:`n` (vertical arrows) and used with the extrapolated tendencies to step forward the flow variables from :math:`n-1/2` to :math:`n+1/2` (solid arc-arrow). The implicit-in-time operator  :math:`{\cal L}_{\bf u,v}` (vertical arrows) is then applied to the previous estimation of the the flow field (:math:`*` -variables) and yields to the two velocity components :math:`u,v` at time level :math:`n+1/2`. These are then used to calculate the advection term (dashed arc-arrow) of the thermo-dynamics tendencies at time step :math:`n`. The extrapolated thermodynamics tendency, from time level :math:`n-1` and :math:`n` to :math:`n+1/2`, allows thermodynamic variables to be stably integrated forward-in-time (solid arc-arrow) up to time level :math:`n+1`.

For well-stratified problems, internal gravity waves may be the limiting
process for determining a stable time-step. In the circumstance, it is
more efficient to stagger in time the thermodynamic variables with the
flow variables. :numref:`adams-bash-staggered` illustrates the
staggering and algorithm. The key difference between this and
:numref:`adams-bash-sync` is that the thermodynamic variables are
solved after the dynamics, using the recently updated flow field. This
essentially allows the gravity wave terms to leap-frog in time giving
second order accuracy and more stability.

The essential change in the staggered algorithm is that the
thermodynamics solver is delayed from half a time step, allowing the use
of the most recent velocities to compute the advection terms. Once the
thermodynamics fields are updated, the hydrostatic pressure is computed
to step forward the dynamics. Note that the pressure gradient must also
be taken out of the Adams-Bashforth extrapolation. Also, retaining the
integer time-levels, :math:`n` and :math:`n+1`, does not give a user the
sense of where variables are located in time. Instead, we re-write the
entire algorithm, :eq:`Gt-n-sync` to :eq:`v-n+1-sync`, annotating the
position in time of variables appropriately:

.. math::
   \phi^{n}_{hyd} =  \int b(\theta^{n},S^{n}) dr
   :label: phi-hyd-staggered

.. math::
   \vec{\bf G}_{\vec{\bf v}}^{n-1/2}  =  \vec{\bf G}_{\vec{\bf v}} ( \vec{\bf v}^{n-1/2} )
   :label: Gv-n-staggered

.. math::
   \vec{\bf G}_{\vec{\bf v}}^{(n)} =  (3/2 + \epsilon_{AB} ) \vec{\bf G}_{\vec{\bf v}}^{n-1/2} - (1/2 + \epsilon_{AB} ) \vec{\bf G}_{\vec{\bf v}}^{n-3/2}
   :label: Gv-n+5-staggered

.. math::
   \vec{\bf v}^{*}  =  \vec{\bf v}^{n-1/2} + \Delta t \left( \vec{\bf G}_{\vec{\bf v}}^{(n)} - \nabla \phi_{hyd}^{n} \right)
   :label: vstar-staggered

.. math::
   \vec{\bf v}^{**}  =  {\cal L}_{\vec{\bf v}}^{-1} ( \vec{\bf v}^* )
   :label: vstarstar-staggered

.. math::
   \eta^*  = \epsilon_{fs} \left( \eta^{n-1/2} + \Delta t (P-E)^n \right)- \Delta t
     \nabla \cdot H \widehat{ \vec{\bf v}^{**} }
   :label: nstar-staggered

.. math::
   \nabla \cdot g H \nabla \eta^{n+1/2}  -  \frac{\epsilon_{fs} \eta^{n+1/2}}{\Delta t^2}
   ~ = ~ - \frac{\eta^*}{\Delta t^2}
   :label: elliptic-staggered

.. math::
   \vec{\bf v}^{n+1/2}  =  \vec{\bf v}^{**} - \Delta t g \nabla \eta^{n+1/2}
   :label: v-n+1-staggered

.. math::
   G_{\theta,S}^{n}  =  G_{\theta,S} ( u^{n+1/2}, \theta^{n}, S^{n} )
   :label: Gt-n-staggered

.. math::
   G_{\theta,S}^{(n+1/2)}  =  (3/2+\epsilon_{AB}) G_{\theta,S}^{n}-(1/2+\epsilon_{AB}) G_{\theta,S}^{n-1}
   :label: Gt-n+5-staggered

.. math::
   (\theta^*,S^*)  =  (\theta^{n},S^{n}) + \Delta t G_{\theta,S}^{(n+1/2)}
   :label: tstar-staggered

.. math::
   (\theta^{n+1},S^{n+1})  =  {\cal L}^{-1}_{\theta,S} (\theta^*,S^*)
   :label: t-n+1-staggered

The corresponding calling tree is given below. The staggered algorithm is
activated with the run-time flag :varlink:`staggerTimeStep` =.TRUE. in
parameter file ``data``, namelist ``PARM01``.

.. admonition:: Staggered Adams-Bashforth calling tree
  :class: note

    | :filelink:`FORWARD\_STEP <model/src/forward_step.F>`
    | :math:`\phantom{WWW}` :filelink:`EXTERNAL\_FIELDS\_LOAD <model/src/external_fields_load.F>`
    | :math:`\phantom{WWW}` :filelink:`DO\_ATMOSPHERIC\_PHYS <model/src/do_atmospheric_phys.F>`
    | :math:`\phantom{WWW}` :filelink:`DO\_OCEANIC\_PHYS <model/src/do_oceanic_phys.F>`
    | :math:`\phantom{WW}` :filelink:`DYNAMICS <model/src/dynamics.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_PHI\_HYD <model/src/calc_phi_hyd.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxi}` :math:`\phi_{hyd}^n` :eq:`phi-hyd-staggered`
    | :math:`\phantom{WWW}` :filelink:`MOM\_FLUXFORM <pkg/mom_fluxform/mom_fluxform.F>` or :filelink:`MOM\_VECINV <pkg/mom_vecinv/mom_vecinv.F>` :math:`\phantom{xxi}` :math:`G_{\vec{\bf v}}^{n-1/2}` :eq:`Gv-n-staggered`
    | :math:`\phantom{WWW}` :filelink:`TIMESTEP <model/src/timestep.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxxxxxx}` :math:`\vec{\bf v}^*` :eq:`Gv-n+5-staggered`, :eq:`vstar-staggered`
    | :math:`\phantom{WWW}` :filelink:`IMPLDIFF  <model/src/impldiff.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxxxxlw}` :math:`\vec{\bf v}^{**}` :eq:`vstarstar-staggered`
    | :math:`\phantom{WW}` :filelink:`UPDATE\_R\_STAR <model/src/update_r_star.F>` or :filelink:`UPDATE\_SURF\_DR <model/src/update_surf_dr.F>` (NonLin-FS only)
    | :math:`\phantom{WW}` :filelink:`SOLVE\_FOR\_PRESSURE <model/src/solve_for_pressure.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_DIV\_GHAT <model/src/calc_div_ghat.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxx}` :math:`\eta^*` :eq:`nstar-staggered`
    | :math:`\phantom{WWW}` :filelink:`CG2D <model/src/cg2d.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxi}` :math:`\eta^{n+1/2}` :eq:`elliptic-staggered`
    | :math:`\phantom{WW}` :filelink:`MOMENTUM\_CORRECTION\_STEP <model/src/momentum_correction_step.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_GRAD\_PHI\_SURF <model/src/calc_grad_phi_surf.F>` :math:`\phantom{xxxxxxxxxxxxxx}` :math:`\nabla \eta^{n+1/2}`
    | :math:`\phantom{WWW}` :filelink:`CORRECTION\_STEP  <model/src/correction_step.F>` :math:`\phantom{xxxxxxxxxxxxxxxxw}` :math:`u^{n+1/2},v^{n+1/2}` :eq:`v-n+1-staggered`
    | :math:`\phantom{WW}` :filelink:`THERMODYNAMICS <model/src/thermodynamics.F>`
    | :math:`\phantom{WWW}` :filelink:`CALC\_GT <model/src/calc_gt.F>`
    | :math:`\phantom{WWWW}` :filelink:`GAD\_CALC\_RHS <pkg/generic_advdiff/gad_calc_rhs.F>` :math:`\phantom{xxxxxxxxxxxxxlwww}` :math:`G_\theta^n = G_\theta( u, \theta^n )` :eq:`Gt-n-staggered`
    | :math:`\phantom{WWWW}` :filelink:`EXTERNAL\_FORCING <model/src/external_forcing.F>` :math:`\phantom{xxxxxxxxxxlww}` :math:`G_\theta^n = G_\theta^n + {\cal Q}`
    | :math:`\phantom{WWWW}` :filelink:`ADAMS\_BASHFORTH2 <model/src/adams_bashforth2.F>` :math:`\phantom{xxxxxxxxxxxw}` :math:`G_\theta^{(n+1/2)}` :eq:`Gt-n+5-staggered`
    | :math:`\phantom{WWW}` :filelink:`TIMESTEP\_TRACER <model/src/timestep_tracer.F>` :math:`\phantom{xxxxxxxxxxxxxxxww}` :math:`\theta^*` :eq:`tstar-staggered`
    | :math:`\phantom{WWW}` :filelink:`IMPLDIFF  <model/src/impldiff.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxxvwww}` :math:`\theta^{(n+1)}` :eq:`t-n+1-staggered`
    | :math:`\phantom{WW}` :filelink:`TRACERS\_CORRECTION\_STEP <model/src/tracers_correction_step.F>`
    | :math:`\phantom{WWW}` :filelink:`CYCLE\_TRACER <model/src/cycle_tracer.F>` :math:`\phantom{xxxxxxxxxxxxxxxxxxxxx}` :math:`\theta^{n+1}`
    | :math:`\phantom{WWW}` :filelink:`SHAP_FILT_APPLY_TS  <pkg/shap_filt/shap_filt_apply_ts.F>` or :filelink:`ZONAL_FILT_APPLY_TS  <pkg/zonal_filt/zonal_filt_apply_ts.F>`
    | :math:`\phantom{WWW}` :filelink:`CONVECTIVE_ADJUSTMENT  <model/src/convective_adjustment.F>`

The only difficulty with this approach is apparent in equation
:eq:`Gt-n-staggered` and illustrated by the dotted arrow connecting
:math:`u,v^{n+1/2}` with :math:`G_\theta^{n}`. The flow used to advect
tracers around is not naturally located in time. This could be avoided
by applying the Adams-Bashforth extrapolation to the tracer field itself
and advecting that around but this approach is not yet available. We’re
not aware of any detrimental effect of this feature. The difficulty lies
mainly in interpretation of what time-level variables and terms
correspond to.

.. _non-hydrostatic:

Non-hydrostatic formulation
===========================


The non-hydrostatic formulation re-introduces the full vertical momentum
equation and requires the solution of a 3-D elliptic equations for
non-hydrostatic pressure perturbation. We still integrate vertically for
the hydrostatic pressure and solve a 2-D elliptic equation for the
surface pressure/elevation for this reduces the amount of work needed to
solve for the non-hydrostatic pressure.

The momentum equations are discretized in time as follows:

.. math::
   \frac{1}{\Delta t} u^{n+1} + g \partial_x \eta^{n+1} + \partial_x \phi_{nh}^{n+1}
   = \frac{1}{\Delta t} u^{n} + G_u^{(n+1/2)}
   :label: discrete-time-u-nh

.. math::
   \frac{1}{\Delta t} v^{n+1} + g \partial_y \eta^{n+1} + \partial_y \phi_{nh}^{n+1}
   = \frac{1}{\Delta t} v^{n} + G_v^{(n+1/2)}
   :label: discrete-time-v-nh

.. math::
   \frac{1}{\Delta t} w^{n+1} + \partial_r \phi_{nh}^{n+1}
   = \frac{1}{\Delta t} w^{n} + G_w^{(n+1/2)}
   :label: discrete-time-w-nh

which must satisfy the discrete-in-time depth integrated continuity,
equation :eq:`discrete-time-backward-free-surface` and the local
continuity equation

.. math::
   \partial_x u^{n+1} + \partial_y v^{n+1} + \partial_r w^{n+1} = 0
   :label: non-divergence-nh

As before, the explicit predictions for momentum are consolidated as:

.. math::

   \begin{aligned}
   u^* & = & u^n + \Delta t G_u^{(n+1/2)} \\
   v^* & = & v^n + \Delta t G_v^{(n+1/2)} \\
   w^* & = & w^n + \Delta t G_w^{(n+1/2)}\end{aligned}

but this time we introduce an intermediate step by splitting the
tendency of the flow as follows:

.. math::

   \begin{aligned}
   u^{n+1} = u^{**} - \Delta t \partial_x \phi_{nh}^{n+1}
   & &
   u^{**} = u^{*} - \Delta t g \partial_x \eta^{n+1} \\
   v^{n+1} = v^{**} - \Delta t \partial_y \phi_{nh}^{n+1}
   & &
   v^{**} = v^{*} - \Delta t g \partial_y \eta^{n+1}\end{aligned}

Substituting into the depth integrated continuity
(equation :eq:`discrete-time-backward-free-surface`) gives

.. math::
   \partial_x H \partial_x \left( g \eta^{n+1} + \widehat{\phi}_{nh}^{n+1} \right)
   + \partial_y H \partial_y \left( g \eta^{n+1} + \widehat{\phi}_{nh}^{n+1} \right)
    - \frac{\epsilon_{fs}\eta^{n+1}}{\Delta t^2}
   = - \frac{\eta^*}{\Delta t^2}
   :label: substituting-in-cont

which is approximated by equation :eq:`elliptic-backward-free-surface`
on the basis that i) :math:`\phi_{nh}^{n+1}` is not yet known and ii)
:math:`\nabla \widehat{\phi}_{nh}
<< g \nabla \eta`. If :eq:`elliptic-backward-free-surface` is solved
accurately then the implication is that :math:`\widehat{\phi}_{nh}
\approx 0` so that the non-hydrostatic pressure field does not drive
barotropic motion.

The flow must satisfy non-divergence (equation :eq:`non-divergence-nh`)
locally, as well as depth integrated, and this constraint is used to
form a 3-D elliptic equations for :math:`\phi_{nh}^{n+1}`:

.. math::
   \partial_{xx} \phi_{nh}^{n+1} + \partial_{yy} \phi_{nh}^{n+1} +
   \partial_{rr} \phi_{nh}^{n+1} =
   \partial_x u^{**} + \partial_y v^{**} + \partial_r w^{*}
   :label: elliptic-pnh

The entire algorithm can be summarized as the sequential solution of the
following equations:

.. math::
   u^{*} = u^{n} + \Delta t G_u^{(n+1/2)}
   :label: ustar-nh

.. math::   
   v^{*} = v^{n} + \Delta t G_v^{(n+1/2)}
   :label: vstar-nh
 
.. math::
   w^{*} = w^{n} + \Delta t G_w^{(n+1/2)}
   :label: wstar-nh

.. math::
   \eta^* ~ = ~ \epsilon_{fs} \left( \eta^{n} + \Delta t (P-E) \right)
   - \Delta t \left( \partial_x H \widehat{u^{*}}
                       + \partial_y H \widehat{v^{*}} \right)
   :label: etastar-nh

.. math::
    \partial_x g H \partial_x \eta^{n+1}
   + \partial_y g H \partial_y \eta^{n+1}
   - \frac{\epsilon_{fs} \eta^{n+1}}{\Delta t^2}
   ~ = ~ - \frac{\eta^*}{\Delta t^2}
   :label: elliptic-nh

.. math::
   u^{**} = u^{*} - \Delta t g \partial_x \eta^{n+1}
   :label: unx-nh

.. math::
   v^{**} = v^{*} - \Delta t g \partial_y \eta^{n+1}
   :label: vnx-nh

.. math::
   \partial_{xx} \phi_{nh}^{n+1} + \partial_{yy} \phi_{nh}^{n+1} +
   \partial_{rr} \phi_{nh}^{n+1} =
   \partial_x u^{**} + \partial_y v^{**} + \partial_r w^{*}
   :label: phi-nh

.. math::
   u^{n+1} = u^{**} - \Delta t \partial_x \phi_{nh}^{n+1}
   :label: un+1-nh

.. math::
   v^{n+1} = v^{**} - \Delta t \partial_y \phi_{nh}^{n+1}
   :label: vn+1-nh}

.. math::
   \partial_r w^{n+1} = - \partial_x u^{n+1} - \partial_y v^{n+1}
   :label: wn+1-nh

where the last equation is solved by vertically integrating for
:math:`w^{n+1}`.

Variants on the Free Surface
============================

We now describe the various formulations of the free-surface that
include non-linear forms, implicit in time using Crank-Nicholson,
explicit and [one day] split-explicit. First, we’ll reiterate the
underlying algorithm but this time using the notation consistent with
the more general vertical coordinate :math:`r`. The elliptic equation
for free-surface coordinate (units of :math:`r`), corresponding to
:eq:`discrete-time-backward-free-surface`, and assuming no
non-hydrostatic effects (:math:`\epsilon_{nh} = 0`) is:

.. math::
   \epsilon_{fs} {\eta}^{n+1} -
   {\bf \nabla}_h \cdot \Delta t^2 (R_o-R_{fixed}) {\bf \nabla}_h b_s
   {\eta}^{n+1} = {\eta}^*
   :label: eq-solve2D

where

.. math::
   {\eta}^* = \epsilon_{fs} \: {\eta}^{n} -
   \Delta t {\bf \nabla}_h \cdot \int_{R_{fixed}}^{R_o} \vec{\bf v}^* dr
   \: + \: \epsilon_{fw} \Delta t (P-E)^{n}
   :label: eq-solve2D_rhs

.. admonition:: S/R  :filelink:`SOLVE_FOR_PRESSURE <model/src/solve_for_pressure.F>`
  :class: note

    | :math:`u^*` : **gU** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )
    | :math:`v^*` : **gV** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )
    | :math:`{\eta}^*` : **cg2d_b** ( :filelink:`SOLVE_FOR_PRESSURE.h <model/inc/SOLVE_FOR_PRESSURE.h>` )
    | :math:`{\eta}^{n+1}` : **etaN** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )


Once :math:`{\eta}^{n+1}` has been found, substituting into
:eq:`discrete-time-u`, :eq:`discrete-time-v` yields
:math:`\vec{\bf v}^{n+1}` if the model is hydrostatic
(:math:`\epsilon_{nh}=0`):

.. math::
   \vec{\bf v}^{n+1} = \vec{\bf v}^{*}
   - \Delta t {\bf \nabla}_h b_s {\eta}^{n+1}

This is known as the correction step. However, when the model is
non-hydrostatic (:math:`\epsilon_{nh}=1`) we need an additional step and
an additional equation for :math:`\phi'_{nh}`. This is obtained by
substituting :eq:`discrete-time-u-nh`, :eq:`discrete-time-v-nh` and
:eq:`discrete-time-w-nh` into continuity:

.. math::
   [ {\bf \nabla}_h^2 + \partial_{rr} ] {\phi'_{nh}}^{n+1}
   = \frac{1}{\Delta t} 
   {\bf \nabla}_h \cdot \vec{\bf v}^{**} + \partial_r \dot{r}^*
   :label: sub-u-v-w-in-cont 

where

.. math:: \vec{\bf v}^{**} = \vec{\bf v}^* - \Delta t {\bf \nabla}_h b_s {\eta}^{n+1}

Note that :math:`\eta^{n+1}` is also used to update the second RHS term
:math:`\partial_r \dot{r}^*` since the vertical velocity at the surface
(:math:`\dot{r}_{surf}`) is evaluated as
:math:`(\eta^{n+1} - \eta^n) / \Delta t`.

Finally, the horizontal velocities at the new time level are found by:

.. math::
   \vec{\bf v}^{n+1} = \vec{\bf v}^{**}
   - \epsilon_{nh} \Delta t {\bf \nabla}_h {\phi'_{nh}}^{n+1}
   :label: v-new-time-lev 

and the vertical velocity is found by integrating the continuity
equation vertically. Note that, for the convenience of the restart
procedure, the vertical integration of the continuity equation has been
moved to the beginning of the time step (instead of at the end), without
any consequence on the solution.

.. admonition:: S/R  :filelink:`CORRECTION_STEP <model/src/correction_step.F>`
  :class: note

    | :math:`{\eta}^{n+1}` : **etaN** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )
    | :math:`{\phi}^{n+1}_{nh}` : **phi_nh** ( :filelink:`NH_VARS.h <model/inc/NH_VARS.h>` )
    | :math:`u^*` : **gU** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )
    | :math:`v^*` : **gV** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )
    | :math:`u^{n+1}` : **uVel** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )
    | :math:`v^{n+1}` : **vVel** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )


Regarding the implementation of the surface pressure solver, all
computation are done within the routine
:filelink:`SOLVE_FOR_PRESSURE <model/src/solve_for_pressure.F>` and its
dependent calls. The standard method to solve the 2D elliptic problem
:eq:`eq-solve2D` uses the conjugate gradient method
(routine :filelink:`CG2D <model/src/cg2d.F>`); the
solver matrix and conjugate gradient operator are only function of the
discretized domain and are therefore evaluated separately, before the
time iteration loop, within :filelink:`INI_CG2D <model/src/ini_cg2d.F>`. The computation of the RHS
:math:`\eta^*` is partly done in :filelink:`CALC_DIV_GHAT <model/src/calc_div_ghat.F>` and in
:filelink:`SOLVE\_FOR\_PRESSURE <model/src/solve_for_pressure.F>`.

The same method is applied for the non hydrostatic part, using a
conjugate gradient 3D solver (:filelink:`CG3D <model/src/cg3d.F>`) that is initialized in
:filelink:`INI_CG3D <model/src/ini_cg3d.F>`. The RHS terms of 2D and 3D problems are computed together
at the same point in the code.

.. toctree::
   :maxdepth:3

   crank-nicol.rst

.. _crank-nicolson_baro:

Crank-Nicolson barotropic time stepping
---------------------------------------

The full implicit time stepping described previously is
unconditionally stable but damps the fast gravity waves, resulting in
a loss of potential energy. The modification presented now allows one
to combine an implicit part (:math:`\beta,\gamma`) and an explicit
part (:math:`1-\beta,1-\gamma`) for the surface pressure gradient
(:math:`\beta`) and for the barotropic flow divergence
(:math:`\gamma`). For instance, :math:`\beta=\gamma=1` is the previous fully implicit
scheme; :math:`\beta=\gamma=1/2` is the non damping (energy
conserving), unconditionally stable, Crank-Nicolson scheme;
:math:`(\beta,\gamma)=(1,0)` or :math:`=(0,1)` corresponds to the
forward - backward scheme that conserves energy but is only stable for
small time steps. In the code, :math:`\beta,\gamma` are defined as parameters,
respectively :varlink:`implicSurfPress`, :varlink:`implicDiv2DFlow`. They are read
from the main parameter file ``data`` (namelist ``PARM01``) and are set
by default to 1,1.

Equations :eq:`ustar-backward-free-surface` –
:eq:`vn+1-backward-free-surface` are modified as follows:

.. math::
   \frac{ \vec{\bf v}^{n+1} }{ \Delta t }
   + {\bf \nabla}_h b_s [ \beta {\eta}^{n+1} + (1-\beta) {\eta}^{n} ]
   + \epsilon_{nh} {\bf \nabla}_h {\phi'_{nh}}^{n+1}
   = \frac{ \vec{\bf v}^{n} }{ \Delta t }
   + \vec{\bf G}_{\vec{\bf v}} ^{(n+1/2)}
   + {\bf \nabla}_h {\phi'_{hyd}}^{(n+1/2)}

.. math::
   \epsilon_{fs} \frac{ {\eta}^{n+1} - {\eta}^{n} }{ \Delta t}
   + {\bf \nabla}_h \cdot \int_{R_{fixed}}^{R_o}
   [ \gamma \vec{\bf v}^{n+1} + (1-\gamma) \vec{\bf v}^{n}] dr
   = \epsilon_{fw} (P-E)
   :label: eta-n+1-CrankNick

We set

.. math::
     \begin{aligned}
     \vec{\bf v}^* & = &
     \vec{\bf v} ^{n} + \Delta t \vec{\bf G}_{\vec{\bf v}} ^{(n+1/2)}
     + (\beta-1) \Delta t {\bf \nabla}_h b_s {\eta}^{n}
     + \Delta t {\bf \nabla}_h {\phi'_{hyd}}^{(n+1/2)}
     \\
     {\eta}^* & = &
     \epsilon_{fs} {\eta}^{n} + \epsilon_{fw} \Delta t (P-E)
     - \Delta t {\bf \nabla}_h \cdot \int_{R_{fixed}}^{R_o}
     [ \gamma \vec{\bf v}^* + (1-\gamma) \vec{\bf v}^{n}] dr\end{aligned}

In the hydrostatic case :math:`\epsilon_{nh}=0`, allowing us to find
:math:`{\eta}^{n+1}`, thus:

.. math::
     \epsilon_{fs} {\eta}^{n+1} -
     {\bf \nabla}_h \cdot \beta\gamma \Delta t^2 b_s (R_o - R_{fixed})
     {\bf \nabla}_h {\eta}^{n+1}
     = {\eta}^*

and then to compute (:filelink:`CORRECTION_STEP <model/src/correction_step.F>`):

.. math::
     \vec{\bf v}^{n+1} = \vec{\bf v}^{*}
     - \beta \Delta t {\bf \nabla}_h b_s {\eta}^{n+1}

Notes:

#. The RHS term of equation :eq:`eta-n+1-CrankNick` corresponds the
   contribution of fresh water flux (P-E) to the free-surface variations
   (:math:`\epsilon_{fw}=1`, :varlink:`useRealFreshWaterFlux` =.TRUE. in parameter
   file ``data``). In order to remain consistent with the tracer equation,
   specially in the non-linear free-surface formulation, this term is
   also affected by the Crank-Nicolson time stepping. The RHS reads:
   :math:`\epsilon_{fw} ( \gamma (P-E)^{n+1/2} + (1-\gamma) (P-E)^{n-1/2} )`
 

#. The stability criteria with Crank-Nicolson time stepping for the pure
   linear gravity wave problem in cartesian coordinates is:

   -  :math:`\beta + \gamma < 1` : unstable

   -  :math:`\beta \geq 1/2` and :math:`\gamma \geq 1/2` : stable

   -  :math:`\beta + \gamma \geq 1` : stable if :math:`c_{max}^2 (\beta - 1/2)(\gamma - 1/2) + 1 \geq 0`
      with :math:`c_{max} = 2 \Delta t \sqrt{gH} \sqrt{ \frac{1}{\Delta x^2} + \frac{1}{\Delta y^2} }`


#. A similar mixed forward/backward time-stepping is also available for
   the non-hydrostatic algorithm, with a fraction :math:`\beta_{nh}`
   (:math:`0 < \beta_{nh} \leq 1`) of the non-hydrostatic pressure
   gradient being evaluated at time step :math:`n+1` (backward in time)
   and the remaining part (:math:`1 - \beta_{nh}`) being evaluated at
   time step :math:`n` (forward in time). The run-time parameter
   :varlink:`implicitNHPress` corresponding to the implicit fraction
   :math:`\beta_{nh}` of the non-hydrostatic pressure is set by default
   to the implicit fraction :math:`\beta` of surface pressure
   (:varlink:`implicSurfPress`), but can also be specified independently (in
   main parameter file ``data``, namelist ``PARM01``).

.. _nonlinear-freesurface:

Non-linear free-surface
-----------------------

Options have been added to the model that concern the free surface formulation.

Pressure/geo-potential and free surface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For the atmosphere, since :math:`\phi = \phi_{topo} - \int^p_{p_s} \alpha dp`, subtracting the
reference state defined in section :numref:`hpe-p-geo-potential-split` :


.. math::
     \phi_o = \phi_{topo} - \int^p_{p_o} \alpha_o dp
     \hspace{5mm}\mathrm{with}\hspace{3mm} \phi_o(p_o)=\phi_{topo}

we get:

.. math:: \phi' = \phi - \phi_o = \int^{p_s}_p \alpha dp - \int^{p_o}_p \alpha_o dp

For the ocean, the reference state is simpler since :math:`\rho_c`
does not dependent on :math:`z` (:math:`b_o=g`) and the surface
reference position is uniformly :math:`z=0` (:math:`R_o=0`), and the
same subtraction leads to a similar relation. For both fluids, using
the isomorphic notations, we can write:

.. math:: \phi' = \int^{r_{surf}}_r b~ dr - \int^{R_o}_r b_o dr

and re-write as:

.. math::
     \phi' = \int^{r_{surf}}_{R_o} b~ dr + \int^{R_o}_r (b - b_o) dr
     :label: split-phi-Ro

or:

.. math::
    \phi' = \int^{r_{surf}}_{R_o} b_o dr + \int^{r_{surf}}_r (b - b_o) dr
    :label: split-phi-bo

In section :numref:`finding_the_pressure_field`, following
eq. :eq:`split-phi-Ro`, the pressure/geo-potential :math:`\phi'` has been
separated into surface (:math:`\phi_s`), and hydrostatic anomaly
(:math:`\phi'_{hyd}`). In this section, the split between :math:`\phi_s`
and :math:`\phi'_{hyd}` is made according to equation :eq:`split-phi-bo`.
This slightly different definition reflects the actual implementation in
the code and is valid for both linear and non-linear free-surface
formulation, in both r-coordinate and r\*-coordinate.

Because the linear free-surface approximation ignores the tracer
content of the fluid parcel between :math:`R_o` and
:math:`r_{surf}=R_o+\eta`, for consistency reasons, this part is also
neglected in :math:`\phi'_{hyd}` :

.. math:: \phi'_{hyd} = \int^{r_{surf}}_r (b - b_o) dr \simeq \int^{R_o}_r (b - b_o) dr

Note that in this case, the two definitions of :math:`\phi_s` and
:math:`\phi'_{hyd}` from equations :eq:`split-phi-Ro` and
:eq:`split-phi-bo` converge toward the same (approximated) expressions:
:math:`\phi_s = \int^{r_{surf}}_{R_o} b_o dr` and
:math:`\phi'_{hyd}=\int^{R_o}_r b' dr`.
On the contrary, the unapproximated formulation (“non-linear
free-surface”, see the next section) retains the full expression:
:math:`\phi'_{hyd} = \int^{r_{surf}}_r (b - b_o) dr` . This is
obtained by selecting :varlink:`nonlinFreeSurf` =4 in parameter file ``data``.
Regarding the surface potential:

.. math::
    \phi_s = \int_{R_o}^{R_o+\eta} b_o dr = b_s \eta
     \hspace{5mm}\mathrm{with}\hspace{5mm}
     b_s = \frac{1}{\eta} \int_{R_o}^{R_o+\eta} b_o dr

:math:`b_s \simeq b_o(R_o)` is an excellent approximation (better
than the usual numerical truncation, since generally :math:`|\eta|` is
smaller than the vertical grid increment).

For the ocean, :math:`\phi_s = g \eta` and :math:`b_s = g` is uniform.
For the atmosphere, however, because of topographic effects, the
reference surface pressure :math:`R_o=p_o` has large spatial variations
that are responsible for significant :math:`b_s` variations (from 0.8 to
1.2 :math:`[m^3/kg]`). For this reason, when :varlink:`uniformLin\_PhiSurf`
=.FALSE. (parameter file ``data``, namelist ``PARAM01``) a non-uniform
linear coefficient :math:`b_s` is used and computed (:filelink:`INI_LINEAR_PHISURF <model/src/ini_linear_phisurf.F>`)
according to the reference surface pressure :math:`p_o`:
:math:`b_s = b_o(R_o) = c_p \kappa (p_o / P^o_{SL})^{(\kappa - 1)} \theta_{ref}(p_o)`,
with :math:`P^o_{SL}` the mean sea-level pressure.

Free surface effect on column total thickness (Non-linear free-surface)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The total thickness of the fluid column is :math:`r_{surf} - R_{fixed} =
\eta + R_o - R_{fixed}`. In most applications, the free surface
displacements are small compared to the total thickness
:math:`\eta \ll H_o = R_o - R_{fixed}`. In the previous sections and in
older version of the model, the linearized free-surface approximation
was made, assuming :math:`r_{surf} - R_{fixed} \simeq H_o` when
computing horizontal transports, either in the continuity equation or in
tracer and momentum advection terms. This approximation is dropped when
using the non-linear free-surface formulation and the total thickness,
including the time varying part :math:`\eta`, is considered when
computing horizontal transports. Implications for the barotropic part
are presented hereafter. In section :numref:`tracer-cons-nonlinear-freesurface`
consequences for tracer conservation is briefly discussed (more details
can be found in Campin et al. (2004) :cite:`cam:04`) ; the general
time-stepping is presented in section :numref:`nonlin-freesurf-timestepping`
with some limitations regarding the vertical resolution in section
:numref:`nonlin-freesurf-dzsurf`.

In the non-linear formulation, the continuous form of the model
equations remains unchanged, except for the 2D continuity equation
:eq:`discrete-time-backward-free-surface` which is now integrated from
:math:`R_{fixed}(x,y)` up to :math:`r_{surf}=R_o+\eta` :

.. math::
   \epsilon_{fs} \partial_t \eta =
   \left. \dot{r} \right|_{r=r_{surf}} + \epsilon_{fw} (P-E) =
   - {\bf \nabla}_h \cdot \int_{R_{fixed}}^{R_o+\eta} \vec{\bf v} dr
   + \epsilon_{fw} (P-E)

Since :math:`\eta` has a direct effect on the horizontal velocity
(through :math:`\nabla_h \Phi_{surf}`), this adds a non-linear term to
the free surface equation. Several options for the time discretization
of this non-linear part can be considered, as detailed below.

If the column thickness is evaluated at time step :math:`n`, and with
implicit treatment of the surface potential gradient, equations
:eq:`eq-solve2D` and :eq:`eq-solve2D_rhs` become:

.. math::

   \begin{aligned}
   \epsilon_{fs} {\eta}^{n+1} -
   {\bf \nabla}_h \cdot \Delta t^2 (\eta^{n}+R_o-R_{fixed})
   {\bf \nabla}_h b_s {\eta}^{n+1}
   = {\eta}^*\end{aligned}

where

.. math::

   \begin{aligned}
   {\eta}^* = \epsilon_{fs} \: {\eta}^{n} -
   \Delta t {\bf \nabla}_h \cdot \int_{R_{fixed}}^{R_o+\eta^n} \vec{\bf v}^* dr
   \: + \: \epsilon_{fw} \Delta_t (P-E)^{n}\end{aligned}

This method requires us to update the solver matrix at each time step.

Alternatively, the non-linear contribution can be evaluated fully
explicitly:

.. math::

   \begin{aligned}
   \epsilon_{fs} {\eta}^{n+1} -
   {\bf \nabla}_h \cdot \Delta t^2 (R_o-R_{fixed})
   {\bf \nabla}_h b_s {\eta}^{n+1}
   = {\eta}^*
   +{\bf \nabla}_h \cdot \Delta t^2 (\eta^{n})
   {\bf \nabla}_h b_s {\eta}^{n}\end{aligned}

This formulation allows one to keep the initial solver matrix unchanged
though throughout the integration, since the non-linear free surface
only affects the RHS.

Finally, another option is a “linearized” formulation where the total
column thickness appears only in the integral term of the RHS
:eq:`eq-solve2D_rhs` but not directly in the equation :eq:`eq-solve2D`.

Those different options (see :numref:`nonlinFreeSurf-flags`) have
been tested and show little differences. However, we recommend the use
of the most precise method (:varlink:`nonlinFreeSurf` =4) since the computation cost
involved in the solver matrix update is negligible.

.. table:: Non-linear free-surface flags
   :name: nonlinFreeSurf-flags

   +---------------------------+---------+----------------------------------------------------------------------------------------+
   | parameter                 | value   | description                                                                            |
   +===========================+=========+========================================================================================+
   |                           | -1      | linear free-surface, restart from a pickup file                                        |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           |         | produced with #undef EXACT\_CONSERV code                                               |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           | 0       | Linear free-surface                                                                    |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   | :varlink:`nonlinFreeSurf` | 4       | Non-linear free-surface                                                                |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           | 3       | same as 4 but neglecting :math:`\int_{R_o}^{R_o+\eta} b' dr` in :math:`\Phi'_{hyd}`    |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           | 2       | same as 3 but do not update cg2d solver matrix                                         |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           | 1       | same as 2 but treat momentum as in Linear FS                                           |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           | 0       | do not use :math:`r*` vertical coordinate (= default)                                  |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   | :varlink:`select_rStar`   | 2       | use :math:`r^*` vertical coordinate                                                    |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           | 1       | same as 2 but without the contribution of the                                          |
   +---------------------------+---------+----------------------------------------------------------------------------------------+
   |                           |         | slope of the coordinate in :math:`\nabla \Phi`                                         |
   +---------------------------+---------+----------------------------------------------------------------------------------------+


.. _tracer-cons-nonlinear-freesurface:

Tracer conservation with non-linear free-surface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To ensure global tracer conservation (i.e., the total amount) as well as
local conservation, the change in the surface level thickness must be
consistent with the way the continuity equation is integrated, both in
the barotropic part (to find :math:`\eta`) and baroclinic part (to find
:math:`w = \dot{r}`).

To illustrate this, consider the shallow water model, with a source of
fresh water (P):

.. math:: \partial_t h + \nabla \cdot h \vec{\bf v} = P

where :math:`h` is the total thickness of the water column. To conserve
the tracer :math:`\theta` we have to discretize:

.. math::
   \partial_t (h \theta) + \nabla \cdot ( h \theta \vec{\bf v})
     = P \theta_{\mathrm{rain}}

Using the implicit (non-linear) free surface described above
(:numref:`press_meth_linear`) we have:

.. math::
   \begin{aligned}
   h^{n+1} = h^{n} - \Delta t \nabla \cdot (h^n \, \vec{\bf v}^{n+1} ) + \Delta t P \\\end{aligned}

The discretized form of the tracer equation must adopt the same “form”
in the computation of tracer fluxes, that is, the same value of
:math:`h`, as used in the continuity equation:

.. math::
   \begin{aligned}
   h^{n+1} \, \theta^{n+1} = h^n \, \theta^n
           - \Delta t \nabla \cdot (h^n \, \theta^n \, \vec{\bf v}^{n+1})
           + \Delta t P \theta_{rain}\end{aligned}

The use of a 3 time-levels time-stepping scheme such as the
Adams-Bashforth make the conservation sightly tricky. The current
implementation with the Adams-Bashforth time-stepping provides an exact
local conservation and prevents any drift in the global tracer content
(Campin et al. (2004) :cite:`cam:04`). Compared to the linear free-surface
method, an additional step is required: the variation of the water
column thickness (from :math:`h^n` to :math:`h^{n+1}`) is not
incorporated directly into the tracer equation. Instead, the model uses
the :math:`G_\theta` terms (first step) as in the linear free surface
formulation (with the “*surface correction*” turned “on”, see tracer
section):

.. math::
   G_\theta^n = \left(- \nabla \cdot (h^n \, \theta^n \, \vec{\bf v}^{n+1})
            - \dot{r}_{surf}^{n+1} \theta^n \right) / h^n

Then, in a second step, the thickness variation (expansion/reduction)
is taken into account:

.. math::
   \theta^{n+1} = \theta^n + \Delta t \frac{h^n}{h^{n+1}}
      \left( G_\theta^{(n+1/2)} + P (\theta_{\mathrm{rain}} - \theta^n )/h^n \right)

Note that with a simple forward time step (no Adams-Bashforth), these
two formulations are equivalent, since
:math:`(h^{n+1} - h^{n})/ \Delta t = P - \nabla \cdot (h^n \, \vec{\bf v}^{n+1} ) = P + \dot{r}_{surf}^{n+1}`

.. _nonlin-freesurf-timestepping:

Time stepping implementation of the non-linear free-surface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The grid cell thickness was hold constant with the linear free-surface;
with the non-linear free-surface, it is now varying in time, at least at
the surface level. This implies some modifications of the general
algorithm described earlier in sections :numref:`adams-bashforth-sync` and
:numref:`adams-bashforth-staggered`.

A simplified version of the staggered in time, non-linear free-surface
algorithm is detailed hereafter, and can be compared to the equivalent
linear free-surface case (eq. :eq:`Gv-n-staggered` to
:eq:`t-n+1-staggered`) and can also be easily transposed to the
synchronous time-stepping case. Among the simplifications, salinity
equation, implicit operator and detailed elliptic equation are
omitted. Surface forcing is explicitly written as fluxes of
temperature, fresh water and momentum,
:math:`Q^{n+1/2}, P^{n+1/2}, F_{\bf v}^n` respectively. :math:`h^n`
and :math:`dh^n` are the column and grid box thickness in
r-coordinate.

  .. math::
     \phi^{n}_{hyd} = \int b(\theta^{n},S^{n},r) dr
     :label: phi-hyd-nlfs

  .. math::
     \vec{\bf G}_{\vec{\bf v}}^{n-1/2}\hspace{-2mm} =
     \vec{\bf G}_{\vec{\bf v}} (dh^{n-1},\vec{\bf v}^{n-1/2})
     \hspace{+2mm};\hspace{+2mm}
     \vec{\bf G}_{\vec{\bf v}}^{(n)} =
        \frac{3}{2} \vec{\bf G}_{\vec{\bf v}}^{n-1/2}
     -  \frac{1}{2} \vec{\bf G}_{\vec{\bf v}}^{n-3/2}
     :label: Gv-n-nlfs

  .. math::
     \vec{\bf v}^{*} = \vec{\bf v}^{n-1/2} + \Delta t \frac{dh^{n-1}}{dh^{n}} \left(
     \vec{\bf G}_{\vec{\bf v}}^{(n)} + F_{\vec{\bf v}}^{n}/dh^{n-1} \right)
     - \Delta t \nabla \phi_{hyd}^{n}
     :label: vstar-nlfs

  .. math::
     \longrightarrow update \phantom{x} model \phantom{x} geometry : {\bf hFac}(dh^n)

  .. math::
     \begin{aligned}
     \eta^{n+1/2} \hspace{-1mm} & =
     \eta^{n-1/2} + \Delta t P^{n+1/2} - \Delta t
     \nabla \cdot \int \vec{\bf v}^{n+1/2} dh^{n} \\
     & = \eta^{n-1/2} + \Delta t P^{n+1/2} - \Delta t
     \nabla \cdot \int \!\!\! \left( \vec{\bf v}^* - g \Delta t \nabla \eta^{n+1/2} \right) dh^{n}\end{aligned}
     :label: nstar-nlfs

  .. math::
     \vec{\bf v}^{n+1/2}\hspace{-2mm} =
     \vec{\bf v}^{*} - g \Delta t \nabla \eta^{n+1/2}
     :label: v-n+1-nlfs

  .. math::
     h^{n+1} = h^{n} + \Delta t P^{n+1/2} - \Delta t
       \nabla \cdot \int \vec{\bf v}^{n+1/2} dh^{n}
     :label: h-n+1-nlfs

  .. math::
     G_{\theta}^{n} = G_{\theta} ( dh^{n}, u^{n+1/2}, \theta^{n} )
     \hspace{+2mm};\hspace{+2mm}
     G_{\theta}^{(n+1/2)} = \frac{3}{2} G_{\theta}^{n} - \frac{1}{2} G_{\theta}^{n-1}
     :label: Gt-n-nlfs

  .. math::
     \theta^{n+1} =\theta^{n} + \Delta t \frac{dh^n}{dh^{n+1}} \left(
     G_{\theta}^{(n+1/2)}
     +( P^{n+1/2} (\theta_{\mathrm{rain}}-\theta^n) + Q^{n+1/2})/dh^n \right)
     \nonumber
     :label: t-n+1-nlfs

Two steps have been added to linear free-surface algorithm (eq.
:eq:`Gv-n-staggered` to :eq:`t-n+1-staggered`): Firstly, the model
“geometry” (here the **hFacC,W,S**) is updated just before entering
:filelink:`SOLVE_FOR_PRESSURE <model/src/solve_for_pressure.F>`,
using the current :math:`dh^{n}` field.
Secondly, the vertically integrated continuity equation
:eq:`h-n+1-nlfs` has been added (:varlink:`exactConserv` =.TRUE., in
parameter file ``data``, namelist ``PARM01``) just before computing the
vertical velocity, in subroutine :filelink:`INTEGR_CONTINUITY <model/src/integr_continuity.F>`. Although this
equation might appear redundant with :eq:`nstar-nlfs`, the
integrated column thickness :math:`h^{n+1}` will be different from
:math:`\eta^{n+1/2} + H`  in the following cases:

-  when Crank-Nicolson time-stepping is used (see :numref:`crank-nicolson_baro`).

-  when filters are applied to the flow field, after :eq:`v-n+1-nlfs`,
   and alter the divergence of the flow.

-  when the solver does not iterate until convergence; for example,
   because a too large residual target was set (:varlink:`cg2dTargetResidual`,
   parameter file ``data``, namelist ``PARM02``).

In this staggered time-stepping algorithm, the momentum tendencies are
computed using :math:`dh^{n-1}` geometry factors :eq:`Gv-n-nlfs`
and then rescaled in subroutine :filelink:`TIMESTEP <model/src/timestep.F>`, :eq:`vstar-nlfs`,
similarly to tracer tendencies (see :numref:`tracer-cons-nonlinear-freesurface`).
The tracers are stepped forward later,
using the recently updated flow field :math:`{\bf v}^{n+1/2}` and the
corresponding model geometry :math:`dh^{n}` to compute the tendencies
:eq:`Gt-n-nlfs`; then the tendencies are rescaled by
:math:`dh^n/dh^{n+1}` to derive the new tracers values
:math:`(\theta,S)^{n+1}` (:eq:`t-n+1-nlfs`, in subroutines :filelink:`CALC_GT <model/src/calc_gt.F>`,
:filelink:`CALC_GS <model/src/calc_gs.F>`).

Note that the fresh-water input is added in a consistent way in the
continuity equation and in the tracer equation, taking into account the
fresh-water temperature :math:`\theta_{\mathrm{rain}}`.

Regarding the restart procedure, two 2D fields :math:`h^{n-1}` and
:math:`(h^n-h^{n-1})/\Delta t` in addition to the standard state
variables and tendencies (:math:`\eta^{n-1/2}`,
:math:`{\bf v}^{n-1/2}`, :math:`\theta^n`, :math:`S^n`,
:math:`{\bf G}_{\bf v}^{n-3/2}`, :math:`G_{\theta,S}^{n-1}`) are
stored in a “*pickup*” file. The model restarts reading this
pickup file, then updates the model geometry according to
:math:`h^{n-1}`, and compute :math:`h^n` and the vertical velocity
before starting the main calling sequence (eq. :eq:`phi-hyd-nlfs` to
:eq:`t-n+1-nlfs`, :filelink:`FORWARD_STEP <model/src/forward_step.F>`).

.. admonition:: S/R  :filelink:`INTEGR_CONTINUITY <model/src/integr_continuity.F>`
  :class: note

    | :math:`h^{n+1} - H_o` : **etaH** ( :filelink:`DYNVARS.h <model/inc/DYNVARS.h>` )
    | :math:`h^n - H_o` : **etaHnm1** ( :filelink:`SURFACE.h <model/inc/SURFACE.h>` )
    | :math:`(h^{n+1} - h^n ) / \Delta t` : **dEtaHdt** ( :filelink:`SURFACE.h <model/inc/SURFACE.h>` )


.. _nonlin-freesurf-dzsurf:

Non-linear free-surface and vertical resolution
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When the amplitude of the free-surface variations becomes as large as
the vertical resolution near the surface, the surface layer thickness
can decrease to nearly zero or can even vanish completely. This later
possibility has not been implemented, and a minimum relative thickness
is imposed (:varlink:`hFacInf`, parameter file ``data``, namelist ``PARM01``) to
prevent numerical instabilities caused by very thin surface level.

A better alternative to the vanishing level problem relies on a different vertical coordinate
:math:`r^*` : The time variation of the total column thickness becomes
part of the :math:`r^*` coordinate motion, as in a :math:`\sigma_{z},\sigma_{p}`
model, but the fixed part related to topography is treated as in a
height or pressure coordinate model. A complete description is given in
Adcroft and Campin (2004) :cite:`adcroft:04a`.

The time-stepping implementation of the :math:`r^*` coordinate is
identical to the non-linear free-surface in :math:`r` coordinate, and
differences appear only in the spacial discretization.


Spatial discretization of the dynamical equations
=================================================

Spatial discretization is carried out using the finite volume method.
This amounts to a grid-point method (namely second-order centered finite
difference) in the fluid interior but allows boundaries to intersect a
regular grid allowing a more accurate representation of the position of
the boundary. We treat the horizontal and vertical directions as
separable and differently.

The finite volume method: finite volumes versus finite difference
-----------------------------------------------------------------

The finite volume method is used to discretize the equations in space.
The expression “finite volume” actually has two meanings; one is the
method of embedded or intersecting boundaries (shaved or lopped cells in
our terminology) and the other is non-linear interpolation methods that
can deal with non-smooth solutions such as shocks (i.e. flux limiters
for advection). Both make use of the integral form of the conservation
laws to which the *weak solution* is a solution on each finite volume of
(sub-domain). The weak solution can be constructed out of piece-wise
constant elements or be differentiable. The differentiable equations can
not be satisfied by piece-wise constant functions.

As an example, the 1-D constant coefficient advection-diffusion
equation:

.. math:: \partial_t \theta + \partial_x ( u \theta - \kappa \partial_x \theta ) = 0

can be discretized by integrating over finite sub-domains, i.e. the
lengths :math:`\Delta x_i`:

.. math:: \Delta x \partial_t \theta + \delta_i ( F ) = 0

is exact if :math:`\theta(x)` is piece-wise constant over the interval
:math:`\Delta x_i` or more generally if :math:`\theta_i` is defined as
the average over the interval :math:`\Delta x_i`.

The flux, :math:`F_{i-1/2}`, must be approximated:

.. math:: F = u \overline{\theta} - \frac{\kappa}{\Delta x_c} \partial_i \theta

and this is where truncation errors can enter the solution. The method
for obtaining :math:`\overline{\theta}` is unspecified and a wide range
of possibilities exist including centered and upwind interpolation,
polynomial fits based on the the volume average definitions of
quantities and non-linear interpolation such as flux-limiters.

Choosing simple centered second-order interpolation and differencing
recovers the same ODE’s resulting from finite differencing for the
interior of a fluid. Differences arise at boundaries where a boundary is
not positioned on a regular or smoothly varying grid. This method is
used to represent the topography using lopped cell, see Adcroft et al. (1997)
:cite:`adcroft:97`. Subtle difference also appear in more
than one dimension away from boundaries. This happens because each
direction is discretized independently in the finite difference method
while the integrating over finite volume implicitly treats all
directions simultaneously. 

C grid staggering of variables
------------------------------

The basic algorithm employed for stepping forward the momentum equations
is based on retaining non-divergence of the flow at all times. This is
most naturally done if the components of flow are staggered in space in
the form of an Arakawa C grid (Arakawa and Lamb, 1977 :cite:`arakawa:77`).

:numref:`cgrid3d` shows the components of flow
(:math:`u`,\ :math:`v`,\ :math:`w`) staggered in space such that the
zonal component falls on the interface between continuity cells in the
zonal direction. Similarly for the meridional and vertical directions.
The continuity cell is synonymous with tracer cells (they are one and
the same).

  .. figure:: figs/cgrid3d.*
    :width: 60%
    :align: center
    :alt: cgrid3d
    :name: cgrid3d

    Three dimensional staggering of velocity components. This facilitates the natural discretization of the continuity and tracer equations.

Grid initialization and data
----------------------------

Initialization of grid data is controlled by subroutine :filelink:`INI_GRID <model/src/ini_grid.F>`
which in calls :filelink:`INI_VERTICAL_GRID <model/src/ini_vertical_grid.F>` to initialize the vertical grid,
and then either of :filelink:`INI_CARTESIAN_GRID <model/src/ini_cartesian_grid.F>`,
:filelink:`INI_SPHERICAL_POLAR_GRID <model/src/ini_spherical_polar_grid.F>`
or :filelink:`INI_CURVILINEAR_GRID <model/src/ini_curvilinear_grid.F>` to initialize the horizontal grid for
cartesian, spherical-polar or curvilinear coordinates respectively.

The reciprocals of all grid quantities are pre-calculated and this is
done in subroutine :filelink:`INI_MASKS_ETC <model/src/ini_masks_etc.F>` which is called later by subroutine
:filelink:`INITIALISE_FIXED <model/src/initialise_fixed.F>`.

All grid descriptors are global arrays and stored in common blocks in
:filelink:`GRID.h <model/inc/GRID.h>` and a generally declared as ``_RS``.


Horizontal grid
---------------

The model domain is decomposed into tiles and within each tile a
quasi-regular grid is used. A tile is the basic unit of domain
decomposition for parallelization but may be used whether parallelized
or not; see section [sec:domain\_decomposition] for more details.
Although the tiles may be patched together in an unstructured manner
(i.e. irregular or non-tessilating pattern), the interior of tiles is a
structured grid of quadrilateral cells. The horizontal coordinate system
is orthogonal curvilinear meaning we can not necessarily treat the two
horizontal directions as separable. Instead, each cell in the horizontal
grid is described by the length of it’s sides and it’s area.

The grid information is quite general and describes any of the available
coordinates systems, cartesian, spherical-polar or curvilinear. All that
is necessary to distinguish between the coordinate systems is to
initialize the grid data (descriptors) appropriately.

In the following, we refer to the orientation of quantities on the
computational grid using geographic terminology such as points of the
compass. This is purely for convenience but should not be confused with
the actual geographic orientation of model quantities.

  .. figure:: figs/hgrid-abcd.*
    :width: 90%
    :align: center
    :alt: hgrid-abcd
    :name: hgrid-abcd
       Staggering of horizontal grid descriptors (lengths and areas). The grid lines indicate the tracer cell boundaries and are the reference grid for all panels. a) The area of a tracer cell, :math:`A_c`, is bordered by the lengths :math:`\Delta x_g` and :math:`\Delta y_g`. b) The area of a vorticity cell, :math:`A_\zeta`, is bordered by the lengths :math:`\Delta x_c` and :math:`\Delta y_c`. c) The area of a u cell, :math:`A_w`, is bordered by the lengths :math:`\Delta x_v` and :math:`\Delta y_f`. d) The area of a v cell, :math:`A_s`, is bordered by the lengths :math:`\Delta x_f` and :math:`\Delta y_u`.

:numref:`hgrid-abcd` (a) shows the tracer cell (synonymous with the continuity
cell). The length of the southern edge, :math:`\Delta x_g`, western
edge, :math:`\Delta y_g` and surface area, :math:`A_c`, presented in the
vertical are stored in arrays **DXg**, **DYg** and **rAc**. The “g”
suffix indicates that the lengths are along the defining grid
boundaries. The “c” suffix associates the quantity with the cell
centers. The quantities are staggered in space and the indexing is such
that **DXg(i,j)** is positioned to the south of **rAc(i,j)** and
**DYg(i,j)** positioned to the west.

:numref:`hgrid-abcd` (b) shows the vorticity cell. The length of the southern
edge, :math:`\Delta x_c`, western edge, :math:`\Delta y_c` and surface
area, :math:`A_\zeta`, presented in the vertical are stored in arrays
**DXc**, **DYc** and **rAz**. The “z” suffix indicates that the lengths
are measured between the cell centers and the “:math:`\zeta`” suffix
associates points with the vorticity points. The quantities are
staggered in space and the indexing is such that **DXc(i,j)** is
positioned to the north of **rAz(i,j)** and **DYc(i,j)** positioned to
the east.

:numref:`hgrid-abcd` (c) shows the “u” or western (w) cell. The length of the
southern edge, :math:`\Delta x_v`, eastern edge, :math:`\Delta y_f` and
surface area, :math:`A_w`, presented in the vertical are stored in
arrays **DXv**, **DYf** and **rAw**. The “v” suffix indicates that the
length is measured between the v-points, the “f” suffix indicates that
the length is measured between the (tracer) cell faces and the “w”
suffix associates points with the u-points (w stands for west). The
quantities are staggered in space and the indexing is such that
**DXv(i,j)** is positioned to the south of **rAw(i,j)** and **DYf(i,j)**
positioned to the east.

:numref:`hgrid-abcd` (d) shows the “v” or southern (s) cell. The length of the
northern edge, :math:`\Delta x_f`, western edge, :math:`\Delta y_u` and
surface area, :math:`A_s`, presented in the vertical are stored in
arrays **DXf**, **DYu** and **rAs**. The “u” suffix indicates that the
length is measured between the u-points, the “f” suffix indicates that
the length is measured between the (tracer) cell faces and the “s”
suffix associates points with the v-points (s stands for south). The
quantities are staggered in space and the indexing is such that
**DXf(i,j)** is positioned to the north of **rAs(i,j)** and **DYu(i,j)**
positioned to the west.

.. admonition:: S/R :filelink:`INI_CARTESIAN_GRID <model/src/ini_cartesian_grid.F>` , :filelink:`INI_SPHERICAL_POLAR_GRID <model/src/ini_spherical_polar_grid.F>` , :filelink:`INI_CURVILINEAR_GRID <model/src/ini_curvilinear_grid.F>`
  :class: note

    | :math:`A_c , A_\zeta , A_w , A_s :` : **rAc, rAz, rAw, rAs** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_g , \Delta y_g` : **DXg, DYg** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_c , \Delta y_c` : **DXc, DYc** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_f , \Delta y_f` : **DXf, DYf** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_v , \Delta y_u` : **DXv, DYu** ( :filelink:`GRID.h <model/inc/GRID.h>` )


Reciprocals of horizontal grid descriptors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lengths and areas appear in the denominator of expressions as much as in
the numerator. For efficiency and portability, we pre-calculate the
reciprocal of the horizontal grid quantities so that in-line divisions
can be avoided.

For each grid descriptor (array) there is a reciprocal named using the
prefix ``RECIP_``. This doubles the amount of storage in :filelink:`GRID.h <model/inc/GRID.h>` but
they are all only 2-D descriptors.

.. admonition:: S/R :filelink:`INI_MASKS_ETC <model/src/ini_masks_etc.F>`
  :class: note

    | :math:`A_c^{-1} , A_\zeta^{-1} , A_w^{-1} , A_s^{-1} :` : **RECIP_Ac, RECIP_Az, RECIP_Aw, RECIP_As** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_g^{-1} , \Delta y_g^{-1}` : **RECIP_DXg, RECIP_DYg** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_c^{-1} , \Delta y_c^{-1}` : **RECIP_DXc, RECIP_DYc** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_f^{-1} , \Delta y_f^{-1}` : **RECIP_DXf, RECIP_DYf** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta x_v^{-1} , \Delta y_u^{-1}` : **RECIP_DXv, RECIP_DYu** ( :filelink:`GRID.h <model/inc/GRID.h>` )

Cartesian coordinates
~~~~~~~~~~~~~~~~~~~~~

Cartesian coordinates are selected when the logical flag
:varlink:`usingCartesianGrid` in namelist ``PARM04`` is set to true. The grid
spacing can be set to uniform via scalars :varlink:`dXspacing` and
:varlink:`dYspacing` in namelist ``PARM04`` or to variable resolution by the
vectors :varlink:`DELX` and :varlink:`DELY`. Units are normally meters.
Non-dimensional coordinates can be used by interpreting the
gravitational constant as the Rayleigh number.

Spherical-polar coordinates
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Spherical coordinates are selected when the logical flag
:varlink:`usingSphericalPolarGrid` in namelist ``PARM04`` is set to true. The
grid spacing can be set to uniform via scalars :varlink:`dXspacing` and
:varlink:`dYspacing` in namelist ``PARM04`` or to variable resolution by the
vectors :varlink:`DELX` and :varlink:`DELY`. Units of these namelist variables are
alway degrees. The horizontal grid descriptors are calculated from these
namelist variables have units of meters.

Curvilinear coordinates
~~~~~~~~~~~~~~~~~~~~~~~

Curvilinear coordinates are selected when the logical flag
:varlink:`usingCurvilinearGrid` in namelist ``PARM04`` is set to true. The grid
spacing can not be set via the namelist. Instead, the grid descriptors
are read from data files, one for each descriptor. As for other grids,
the horizontal grid descriptors have units of meters.

Vertical grid
-------------

  .. figure:: figs/vgrid-accur-center.*
    :width: 70%
    :align: center
    :alt: vgrid-accur-center
    :name: vgrid-accur-center

    Two versions of the vertical grid. a) The cell centered approach where the interface depths are specified and the tracer points centered in between the interfaces. b) The interface centered approach where tracer levels are specified and the w-interfaces are centered in between.

As for the horizontal grid, we use the suffixes “c” and “f” to indicates
faces and centers. :numref:`vgrid-accur-center` (a) shows the default vertical grid
used by the model. :math:`\Delta r_f` is the difference in :math:`r`
(vertical coordinate) between the faces (i.e. :math:`\Delta r_f \equiv -
\delta_k r` where the minus sign appears due to the convention that the
surface layer has index :math:`k=1`.).

The vertical grid is calculated in subroutine :filelink:`INI_VERTICAL_GRID <model/src/ini_vertical_grid.F>` and
specified via the vector :varlink:`DELR` in namelist ``PARM04``. The units of “r”
are either meters or Pascals depending on the isomorphism being used
which in turn is dependent only on the choice of equation of state.

There are alternative namelist vectors :varlink:`DELZ` and :varlink:`DELP` which
dictate whether z- or p- coordinates are to be used but we intend to
phase this out since they are redundant.

The reciprocals :math:`\Delta r_f^{-1}` and :math:`\Delta r_c^{-1}` are
pre-calculated (also in subroutine :filelink:`INI_VERTICAL_GRID <model/src/ini_vertical_grid.F>`). All vertical
grid descriptors are stored in common blocks in :filelink:`GRID.h <model/inc/GRID.h>`.

The above grid :numref:`vgrid-accur-center` (a) is known as the cell centered
approach because the tracer points are at cell centers; the cell centers
are mid-way between the cell interfaces. This discretization is selected
when the thickness of the levels are provided (:varlink:`delR`, parameter file
``data``, namelist ``PARM04``) An alternative, the vertex or interface
centered approach, is shown in :numref:`vgrid-accur-center` (b). Here, the interior
interfaces are positioned mid-way between the tracer nodes (no longer
cell centers). This approach is formally more accurate for evaluation of
hydrostatic pressure and vertical advection but historically the cell
centered approach has been used. An alternative form of subroutine
:filelink:`INI_VERTICAL_GRID <model/src/ini_vertical_grid.F>` is used to select the interface centered approach
This form requires to specify :math:`Nr+1` vertical distances :varlink:`delRc`
(parameter file ``data``, namelist ``PARM04``, e.g.
:filelink:`ideal\_2D\_oce/input/data <verification/ideal_2D_oce/input/data>`) corresponding to surface to
center, :math:`Nr-1` center to center, and center to bottom distances.

.. admonition:: S/R :filelink:`INI_VERTICAL_GRID <model/src/ini_vertical_grid.F>`
  :class: note

    | :math:`\Delta r_f , \Delta r_c` : **DRf, DRc** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`\Delta r_f^{-1} , \Delta r_c^{-1}` : **RECIP_DRfc, RECIP_DRc** ( :filelink:`GRID.h <model/inc/GRID.h>` )


Topography: partially filled cells
----------------------------------

<!– CMIREDIR:topo\_partial\_cells: –>

Adcroft et al. (1997) :cite:`adcroft:97` presented two alternatives to the
step-wise finite difference representation of topography. The method is
known to the engineering community as *intersecting boundary method*. It
involves allowing the boundary to intersect a grid of cells thereby
modifying the shape of those cells intersected. We suggested allowing
the topography to take on a piece-wise linear representation (shaved
cells) or a simpler piecewise constant representation (partial step).
Both show dramatic improvements in solution compared to the traditional
full step representation, the piece-wise linear being the best. However,
the storage requirements are excessive so the simpler piece-wise
constant or partial-step method is all that is currently supported.

  .. figure:: figs/vgrid-xz.*
    :width: 70%
    :align: center
    :alt: vgrid-xz
    :name: vgrid-xz

    A schematic of the x-r plane showing the location of the non-dimensional fractions :math:`h_c` and :math:`h_w` . The physical thickness of a tracer cell is given by :math:`h_c(i,j,k) \Delta r_f(k)` and the physical thickness of the open side is given by  :math:`h_w(i,j,k) \Delta r_f(k)` .

:numref:`vgrid-xz` shows a schematic of the x-r plane indicating how the
thickness of a level is determined at tracer and u points. The physical
thickness of a tracer cell is given by :math:`h_c(i,j,k) \Delta
r_f(k)` and the physical thickness of the open side is given by
:math:`h_w(i,j,k) \Delta r_f(k)`. Three 3-D descriptors :math:`h_c`,
:math:`h_w` and :math:`h_s` are used to describe the geometry:
:varlink:`hFacC`, :varlink:`hFacW` and :varlink:`hFacS` respectively. These are calculated in
subroutine :filelink:`INI_MASKS_ETC <model/src/ini_masks_etc.F>` along with there reciprocals
:varlink:`RECIP_hFacC`, :varlink:`RECIP_hFacW` and :varlink:`RECIP_hFacS`.

The non-dimensional fractions (or h-facs as we call them) are calculated
from the model depth array and then processed to avoid tiny volumes. The
rule is that if a fraction is less than :varlink:`hFacMin` then it is rounded
to the nearer of :math:`0` or :varlink:`hFacMin` or if the physical thickness
is less than :varlink:`hFacMinDr` then it is similarly rounded. The larger of
the two methods is used when there is a conflict. By setting
:varlink:`hFacMinDr` equal to or larger than the thinnest nominal layers,
:math:`\min{(\Delta z_f)}`, but setting :varlink:`hFacMin` to some small
fraction then the model will only lop thick layers but retain stability
based on the thinnest unlopped thickness;
:math:`\min{(\Delta z_f,hFacMinDr)}`.

.. admonition:: S/R :filelink::filelink:`INI_MASKS_ETC <model/src/ini_masks_etc.F>`
  :class: note

    | :math:`h_c , h_w , h_s` : **hFacC, hFacW, hFacS** ( :filelink:`GRID.h <model/inc/GRID.h>` )
    | :math:`h_c^{-1} , h_w^{-1} , h_s^{-1}` : **RECIP_hFacC, RECIP_hFacW, RECIP_hFacS** ( :filelink:`GRID.h <model/inc/GRID.h>` )


Continuity and horizontal pressure gradient terms
=================================================


The core algorithm is based on the “C grid” discretization of the
continuity equation which can be summarized as:

.. math::
   \partial_t u + \frac{1}{\Delta x_c} \delta_i \left. \frac{ \partial \Phi}{\partial r}\right|_{s} \eta + \frac{\epsilon_{nh}}{\Delta x_c} \delta_i \Phi_{nh}' = G_u - \frac{1}{\Delta x_c} \delta_i \Phi_h'
   :label: discrete-momu

.. math::
   \partial_t v + \frac{1}{\Delta y_c} \delta_j \left. \frac{ \partial \Phi}{\partial r}\right|_{s} \eta + \frac{\epsilon_{nh}}{\Delta y_c} \delta_j \Phi_{nh}' = G_v - \frac{1}{\Delta y_c} \delta_j \Phi_h'
   :label: discrete-momv

.. math::
   \epsilon_{nh} \left( \partial_t w + \frac{1}{\Delta r_c} \delta_k \Phi_{nh}' \right) = \epsilon_{nh} G_w + \overline{b}^k - \frac{1}{\Delta r_c} \delta_k \Phi_{h}'
   :label: discrete-momw

.. math::
   \delta_i \Delta y_g \Delta r_f h_w u +
   \delta_j \Delta x_g \Delta r_f h_s v +
   \delta_k {\cal A}_c w  = {\cal A}_c \delta_k (P-E)_{r=0}
   :label: discrete-continuity

where the continuity equation has been most naturally discretized by
staggering the three components of velocity as shown in
:numref:`cgrid3d`. The grid lengths :math:`\Delta x_c` and
:math:`\Delta y_c` are the lengths between tracer points (cell centers).
The grid lengths :math:`\Delta x_g`, :math:`\Delta y_g` are the grid
lengths between cell corners. :math:`\Delta r_f` and :math:`\Delta r_c`
are the distance (in units of :math:`r`) between level interfaces
(w-level) and level centers (tracer level). The surface area presented
in the vertical is denoted :math:`{\cal
A}_c`. The factors :math:`h_w` and :math:`h_s` are non-dimensional
fractions (between 0 and 1) that represent the fraction cell depth that
is “open” for fluid flow.

The last equation, the discrete continuity equation, can be summed in
the vertical to yield the free-surface equation:

.. math::
  {\cal A}_c \partial_t \eta + \delta_i \sum_k \Delta y_g \Delta r_f h_w
   u + \delta_j \sum_k \Delta x_g \Delta r_f h_s v = {\cal
   A}_c(P-E)_{r=0}
  :label: discrete-freesurface

The source term :math:`P-E` on the rhs of continuity accounts for the
local addition of volume due to excess precipitation and run-off over
evaporation and only enters the top-level of the ocean model.

Hydrostatic balance
===================

The vertical momentum equation has the hydrostatic or quasi-hydrostatic
balance on the right hand side. This discretization guarantees that the
conversion of potential to kinetic energy as derived from the buoyancy
equation exactly matches the form derived from the pressure gradient
terms when forming the kinetic energy equation.

In the ocean, using z-coordinates, the hydrostatic balance terms are
discretized:

.. math::
   \epsilon_{nh} \partial_t w
   + g \overline{\rho'}^k + \frac{1}{\Delta z} \delta_k \Phi_h' = \ldots
   :label: discrete_hydro_ocean

In the atmosphere, using p-coordinates, hydrostatic balance is
discretized:

.. math::
   \overline{\theta'}^k + \frac{1}{\Delta \Pi} \delta_k \Phi_h' = 0
   :label: discrete_hydro_atmos

where :math:`\Delta \Pi` is the difference in Exner function between
the pressure points. The non-hydrostatic equations are not available in
the atmosphere.

The difference in approach between ocean and atmosphere occurs because
of the direct use of the ideal gas equation in forming the potential
energy conversion term :math:`\alpha \omega`. Because of the different
representation of hydrostatic balance between
ocean and atmosphere there is no elegant way to represent both systems
using an arbitrary coordinate.

The integration for hydrostatic pressure is made in the positive
:math:`r` direction (increasing k-index). For the ocean, this is from
the free-surface down and for the atmosphere this is from the ground up.

The calculations are made in the subroutine :filelink:`CALC_PHI_HYD <model/src/calc_phi_hyd.F>`. Inside
this routine, one of other of the atmospheric/oceanic form is selected
based on the string variable :varlink:`buoyancyRelation`.
